# Knowledge Base: Automated Component Registry

## 1. The Component Mapping Problem

In a JSON-driven UI architecture, such as the one described in `SPEC-UI-001`, the A2UI JSON payload contains declarative instructions on what to render. For example, a piece of JSON might say: `{"type": "card", "title": "Welcome"}`.

The UI renderer's job is to take this instruction and render the actual `Card` component from your component library. This requires a mapping mechanismâ€”a way to connect the string `"card"` to the `Card` component implementation in your codebase. This mapping is handled by a **component registry**.

Manually maintaining this registry is a significant pain point in large-scale projects:

-   **Error-Prone:** Developers frequently forget to register new components, leading to runtime errors where the renderer doesn't know what to do with a given `type`.
-   **Tedious:** It's a repetitive, boilerplate task that adds friction to the development process.
-   **Synchronization Issues:** The registry can easily get out of sync with the actual component library, especially when components are renamed or deleted.

## 2. The SmartSpec Solution: `/smartspec_generate_component_registry`

The `/smartspec_generate_component_registry` workflow completely eliminates this manual step. It automates the creation and maintenance of the component registry file, ensuring it is always a perfect reflection of your component library.

> This workflow scans your component directories, identifies all exported components, and generates a registry file that maps component names to their implementations. It turns a tedious manual task into a reliable, automated process.

### How It Works

The workflow is designed to be simple to use but powerful in its execution:

1.  **Scan Directory:** It recursively scans the specified `--scan-dir` for all component files (e.g., `.tsx`, `.jsx`).
2.  **Parse Exports:** Using regular expressions, it parses the content of each file to identify all named exports. It is optimized for common patterns like `export const MyComponent = ...` and `export { MyComponent }`.
3.  **Generate Imports:** For each discovered component, it generates a corresponding import statement at the top of the output file.
4.  **Create Mapper:** It then creates a `ComponentMapper` object (or a simple JavaScript object) that maps the component's string name to its imported class or function.
5.  **Write File:** The complete registry, including all imports and the mapper object, is written to the specified `--output-file`.

### Example

Given a directory `src/components/` containing `Card.tsx` and `Button.tsx`, the command:

```bash
/smartspec_generate_component_registry \
  --scan-dir "src/components/" \
  --output-file "src/config/component-registry.ts"
```

Will generate a `component-registry.ts` file that looks something like this:

```typescript
// This file is auto-generated by SmartSpec. Do not edit manually.

import { Card } from '../components/Card';
import { Button } from '../components/Button';

export const ComponentMapper = {
  'Card': Card,
  'Button': Button,
};
```

This file can then be directly imported and used by your UI renderer.

## 3. Integrating with Your Development Workflow

To maximize the benefits of this workflow, it should be integrated directly into your development and CI/CD processes.

### Pre-Commit Hook

One of the most effective ways to use this workflow is to run it as a **pre-commit hook**. This ensures that the component registry is automatically updated every time a developer commits code. If a new component has been added, it will be registered before the code even reaches the remote repository.

Most modern projects use tools like **Husky** [1] to manage Git hooks. You can configure Husky to run the `generate_component_registry` command before each commit.

### CI/CD Pipeline

As an additional layer of safety, you can also add this workflow as a step in your Continuous Integration (CI) pipeline. This guarantees that the registry is always up-to-date in your production builds, even if a developer somehow bypasses the pre-commit hook.

## 4. Advanced Usage and Best Practices

### Base Registry

The workflow supports a `--base-registry` parameter, which allows you to include components from an external library (e.g., Material-UI, Ant Design) without needing to scan them. You can provide a JSON file that maps component names to their import sources, and the workflow will merge these with your locally scanned components.

### Best Practices

-   **Use Named Exports:** The workflow is optimized for named exports. Avoid default exports for components that you want to be automatically registered.
-   **Consistent Naming:** Ensure your component filenames and exported component names are consistent (e.g., `Card.tsx` exports a component named `Card`).
-   **Run It Automatically:** The real power of this workflow is unlocked when it is run automatically. Set it up in a pre-commit hook or CI pipeline to make it a seamless part of your development process.

By automating the component registry, you remove a significant source of friction and potential errors from your JSON-driven UI architecture, allowing your team to focus on what they do best: building great components.

---

## References

[1] Typicode. *Husky*. [https://typicode.github.io/husky/](https://typicode.github.io/husky/)
