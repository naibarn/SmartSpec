name: /smartspec_ui_validation
version: 5.6.4
role: verification/governance
write_guard: NO-WRITE
purpose: Validate implemented UI behavior and coverage against UI specs
         (including JSON-first UI generated by AI), flows, and
         acceptance criteria, using existing test artifacts and
         reports, without modifying code, configs, or running tests.
---

## 1) Summary

`/smartspec_ui_validation` reads SmartSpec artifacts, UI specs (including
JSON-first UI definitions), implementation structure, and existing UI
test outputs to produce a **UI validation report**.

The workflow focuses on:

- mapping **screens and flows** from spec/UI JSON to actual
  implementation
- checking **validation coverage** across:
  - behavior and flows (happy paths + edge cases)
  - error states and input validation
  - accessibility (a11y)
  - visual/snapshot regression
  - internationalization (i18n) / localization
  - cross-environment / cross-device combinations (where evidence
    exists)
- computing **per-UI-unit status** and `blocking_for_release` signals
- treating **AI-generated `ui.json`** as first-class input, with
  metadata and quality signals

> **Governance-only:**
> - This workflow does **not** run tests (e2e/unit/snapshot).
> - It does **not** modify UI code, test code, configs, or assets.
> - It does **not** change specs, UI JSON, or CI definitions.
> - It only reads existing artifacts and produces a validation report.
>
> **Sensitive data rule:**
> - The report MUST NOT embed real user data, secrets, tokens, or
>   session identifiers from screenshots/logs/HTML.
> - It may refer to component/field names, states, and structural
>   properties only.
>
> **Executable test rule:**
> - The workflow MAY describe test patterns and missing coverage
>   conceptually but MUST NOT emit ready-to-run test runner commands or
>   scripts as "approved" or implicitly safe to execute.
>
> **Scope vs `/smartspec_ui_consistency_audit`:**
> - `/smartspec_ui_validation` focuses on **correctness & coverage**
>   (does UI behave as specified, and is it validated?).
> - `/smartspec_ui_consistency_audit` focuses on **design/system
>   consistency** (tokens, spacing, patterns, visual coherence, theme
>   usage, AI UI JSON quality).
> - They are complementary and may be used together.

Use this workflow when you want a **structured, spec-aligned view of how
well your UI has been validated before release**, including how much you
can trust AI-generated `ui.json` for each UI unit.

The `blocking_for_release` recommendations from this workflow are
intended as **governance signals** for release and change control,
consumed alongside other workflows such as
`/smartspec_ui_consistency_audit` and `/smartspec_release_readiness`.
They do not override other workflows but should be explicitly addressed
by release decision-makers.

---

## 2) When to Use

Use `/smartspec_ui_validation` when:

- UI screens/flows are designed and documented in:
  - markdown specs, and/or
  - JSON-first UI definitions (`ui.json` or equivalent)
- UI implementation exists (web/mobile/desktop) and:
  - you have UI test suites (e2e, component, snapshot), and/or
  - a11y / visual regression / i18n checks
- `ui.json` is often generated by AI and you want to understand:
  - where it is trusted
  - where it is unreviewed
  - and how much validation exists on top of it

Typical chain:

`design_feature → design_UI (spec + ui.json) → generate_ui.json (AI) → implement_UI → implement_UI_tests → CI runs tests → /smartspec_ui_validation → /smartspec_release_readiness`

Do **not** use this workflow to:

- generate or edit UI tests directly (it may suggest missing coverage,
  but not commit changes)
- enforce design tokens / spacing / visual language (use
  `/smartspec_ui_consistency_audit`)
- run browsers, devices, or test runners

---

## 3) Inputs / Outputs

### 3.1 Inputs (artifacts, read-only)

- **Index**
  - `.spec/SPEC_INDEX.json` (canonical)
  - `SPEC_INDEX.json` at repo root (legacy)
  - `.smartspec/SPEC_INDEX.json` (deprecated)
  - `specs/SPEC_INDEX.json` (older layout)

- **Specs & tasks**
  - `specs/<category>/<spec-id>/spec.md`
  - `specs/<category>/<spec-id>/tasks.md`
  - any UI-specific docs referenced in SPEC_INDEX
    (e.g., `ui.md`, `ux_flows.md`, `acceptance_criteria.md`)

- **UI specs (JSON-first & alternatives)**
  - canonical UI JSON locations defined by your base SmartSpec
    governance (e.g., `.spec/ui/` or
    `specs/<category>/<spec-id>/ui.json`).
  - additional paths from `--ui-spec-paths`, which may include:
    - JSON-first UI definitions (`ui.json`, `*.ui.json`, etc.)
    - structured UI config for screens/routes/components
  - UI JSON is treated as primary when present, especially in
    JSON-first UI projects.

  The workflow expects (but does not enforce) a `meta` block in
  `ui.json`, for example:

  ```jsonc
  {
    "meta": {
      "source": "ai",              // ai | human | mixed | unknown
      "generator": "kilo-code-vX", // or workflow/agent id
      "generated_at": "2025-12-09T12:34:56Z",
      "design_system_version": "ds-v3.1",
      "style_preset": "modern-dashboard-v2",
      "review_status": "unreviewed" // unreviewed | designer_approved | overridden
    },
    "screens": [ /* ... */ ]
  }
  ```

  When such metadata is present, the workflow MUST read and use it as a
  signal for origin, review status, and quality.

- **UI implementation structure (optional)**
  - `--ui-impl-paths` (glob patterns for UI source code directories)
  - used heuristically to:
    - map routes/components to spec/UI JSON entries
    - detect where certain flows likely reside

- **UI test artifacts (read-only)**
  - `--ui-test-report-paths`
    - e2e / functional test reports (e.g., JSON, JUnit XML, markdown)
  - `--ui-snapshot-report-paths`
    - visual regression/snapshot test reports
  - `--ui-accessibility-report-paths`
    - accessibility reports (e.g., axe, Lighthouse export)
  - `--ui-i18n-report-paths`
    - i18n coverage or linting reports

All artifacts are treated as **read-only**.

### 3.2 Inputs (flags)

See **5) Flags**.

### 3.3 Outputs

- **UI validation report**
  - default location:
    `.spec/reports/smartspec_ui_validation/<timestamp>_<run-label>.md`
  - if `--report-format=json`:
    `.spec/reports/smartspec_ui_validation/<timestamp>_<run-label>.json`

#### 3.3.1 Per-UI-unit status model

A **UI unit** typically represents a screen, route, or user flow defined
in UI specs / JSON.

For each unit, the report SHOULD include at least:

- `unit_id`
  - label such as route (`/checkout`), screen ID, or flow name.

- `criticality`
  - `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`, `UNKNOWN` — derived from UI
    specs/registries.

- `ui_spec_origin`
  - `AI`, `HUMAN`, `MIXED`, `UNKNOWN`
  - derived from `ui.json` meta (e.g., `meta.source`) when present, or
  - inferred/left `UNKNOWN` otherwise.

- `ui_spec_review_status`
  - `UNREVIEWED`, `DESIGNER_APPROVED`, `OVERRIDDEN`, `UNKNOWN`
  - derived from `ui.json` meta (e.g., `meta.review_status`) or
  - registries, if available.

- `ui_json_quality_status`
  - `STRONG` – UI JSON appears coherent, complete, and aligned with
    design system and flows.
  - `OK` – generally acceptable, some minor issues.
  - `WEAK` – incomplete structure, missing key states, or mismatched
    flows.
  - `BROKEN` – clearly inconsistent/invalid or conflicting with specs.
  - `UNKNOWN` – insufficient info.

- `spec_coverage_status`
  - `FULL` – spec/UI JSON clearly defines this unit, and it is mapped.
  - `PARTIAL` – partial mapping/definition exists.
  - `NONE` – unit exists in implementation but not in spec/UI JSON.
  - `UNKNOWN` – insufficient info.

- `behavior_validation_status`
  - `STRONG` – key flows (happy path + main edge cases) have passing
    tests.
  - `BASIC` – only minimal path(s) validated.
  - `NONE` – no evidence of behavior tests.
  - `UNKNOWN` – unclear.

- `error_state_coverage_status`
  - `COMPREHENSIVE` – common error/validation states covered.
  - `PARTIAL` – some states covered.
  - `NONE` – no error/validation coverage.
  - `UNKNOWN` – unclear.

- `input_validation_coverage_status`
  - `COMPREHENSIVE` – critical fields’ validation covered.
  - `PARTIAL`
  - `NONE`
  - `UNKNOWN`

- `accessibility_status`
  - `GOOD` – strong a11y evidence (reports/tests) with no blocking
    issues.
  - `ISSUES_NON_BLOCKING` – issues found, but non-blocking.
  - `ISSUES_BLOCKING` – issues that should block release.
  - `UNKNOWN` – no a11y evidence.

- `visual_regression_status`
  - `COVERED` – visual tests present and passing.
  - `PARTIAL` – partial coverage or unstable results.
  - `NONE`
  - `UNKNOWN`.

- `i18n_status`
  - `COVERED` – main locales covered; text externalized.
  - `PARTIAL` – partial locale coverage or known issues.
  - `NONE` – no i18n coverage.
  - `UNKNOWN`.

- `cross_env_status`
  - `COVERED` – evidence across all relevant browsers/devices/envs
    that the spec/flags/registries mark as required.
  - `PARTIAL` – some but not all required environments covered.
  - `NONE` – no explicit cross-env coverage.
  - `UNKNOWN` – cannot determine.

- `risk_level`
  - `LOW`, `MEDIUM`, `HIGH`, `CRITICAL`.

- `blocking_for_release`
  - `true` | `false` – recommendation for release gating.

- `notes`
  - explanation and context.

#### 3.3.2 Aggregated summary

The report SHOULD also include:

- counts of units by `risk_level`
- counts by `blocking_for_release`
- counts of units with:
  - `accessibility_status=ISSUES_BLOCKING`
  - `visual_regression_status=NONE/UNKNOWN` (for critical/high units)
  - `spec_coverage_status=NONE/UNKNOWN` (for critical/high units)
  - `behavior_validation_status=NONE/UNKNOWN` (for critical/high units)
  - `cross_env_status=PARTIAL/NONE` when multiple target
    environments/devices are required
  - `ui_spec_origin=AI` & `ui_spec_review_status=UNREVIEWED` for
    critical/high units
  - `ui_json_quality_status=WEAK/BROKEN`

> **Canonical structure note:**
> - When `--report-format=json`, the JSON structure (per-unit fields
>   above + summary section) is the canonical representation.
> - The markdown variant MUST present the same per-unit fields (e.g., as
>   tables or clearly labeled sections) so that tooling can map between
>   `.md` and `.json` deterministically.

Optionally, a **stdout summary** when `--stdout-summary` is enabled.

---

## 4) Modes

### 4.1 Role & write guard

- Role: **Verification / Governance**
- Write guard: **NO-WRITE**

MUST NOT:

- run UI tests or open browsers/devices.
- modify UI code, test code, configs, or UI assets.
- edit specs, UI JSON, or CI.

MAY:

- read artifacts and reports.
- generate UI validation reports under `.spec/reports/...`.
- print human-readable summaries.

### 4.2 Platform semantics

- Tool/framework-agnostic:
  - no hard dependency on specific UI framework (React/Vue/Native/etc.).
  - works primarily via specs + reports, not runtime execution.

- Under Kilo (with `--kilocode` and Kilo detected):

  - effective mode: **Ask / Architect**, **NO-WRITE**.
  - must follow **Kilo Orchestrator-per-task rule**:
    - before each top-level task (each spec-id or UI flow group),
      switch to Orchestrator and decompose subtasks, unless
      `--nosubtasks` is set.
  - default under Kilo: **subtasks ON**.

  - typical loop:
    1) Orchestrator picks one spec-id / UI flow group.
    2) Subtasks (examples):
       - gather UI spec (markdown + UI JSON + meta).
       - map UI units to implementation.
       - gather test & report artifacts.
       - compute per-unit statuses including AI-origin signals.
    3) Code mode (read-only) parses reports and mapping.
    4) Orchestrator assembles unit statuses and summary.

- If `--kilocode` is present but Kilo is not detected:
  - treat `--kilocode` as a **no-op meta-flag**.
  - run a single-flow reasoning path.

Write guard stays **NO-WRITE** in all modes.

---

## 5) Flags

> All flags are additive; no legacy flags are changed.

### 5.1 Scope & labeling

- `--spec-ids=<id1,id2,...>`
  - spec-ids whose UI should be validated.
  - all IDs must exist in SPEC_INDEX.

- `--ui-targets=<id1,id2,...>`
  - optional list of UI units (screens/routes/flows) to focus on.
  - if omitted, attempt to validate all units under the given spec-ids.

- `--ui-critical-targets=<id1,id2,...>`
  - optional explicit list of `unit_id`s that should be treated as
    `critical` regardless of registry/spec heuristics (e.g.,
    `login`, `checkout`, `payment_confirmation`).

- `--include-dependencies`
  - include dependent UI surfaces (e.g., shared components/layouts)
    identified via SPEC_INDEX/registries.

- `--run-label=<string>`
  - label for this validation run (used in filenames/headers).

### 5.2 UI spec & implementation

- `--ui-spec-paths="<glob1>;<glob2>;..."`
  - where to find UI specs / JSON-first UI definitions.

- `--ui-impl-paths="<glob1>;<glob2>;..."`
  - UI implementation source directories.

- `--ui-json-mode=<auto|required|disabled>`
  - `auto` (default): try to detect UI JSON (canonical path + glob);
    fallback to markdown specs.
  - `required`: expect UI JSON to exist for relevant spec-ids; missing
    JSON is a validation gap and influences `spec_coverage_status` and
    `ui_json_quality_status`.
  - `disabled`: assume no JSON separation; rely on markdown specs and
    other docs.

- `--ui-json-ai-strict`
  - optional flag to enforce stricter rules for AI-generated UI JSON
    (aligned with `/smartspec_ui_consistency_audit`):
    - treat `ui_spec_origin=AI` & `ui_spec_review_status=UNREVIEWED`
      for critical/high units as at least `HIGH` risk.
    - require `design_system_version` and `style_preset` metadata to be
      present; absence is treated as a validation gap and reduces
      `ui_json_quality_status`.

### 5.3 UI test & report artifacts

- `--ui-test-report-paths="<glob1>;<glob2>;..."`
- `--ui-snapshot-report-paths="<glob1>;<glob2>;..."`
- `--ui-accessibility-report-paths="<glob1>;<glob2>;..."`
- `--ui-i18n-report-paths="<glob1>;<glob2>;..."`

All treated as **read-only inputs**.

### 5.4 Environment & platform

- `--target-envs=<env1,env2,...>`
  - e.g., `web,ios,android,desktop`.

- `--target-browsers=<id1,id2,...>`
  - e.g., `chromium,firefox,safari`.

- `--target-devices=<id1,id2,...>`
  - e.g., `mobile,tablet,desktop`.

These identify **expected** coverage; if reports show coverage only
for a subset, `cross_env_status` should reflect `PARTIAL` or `NONE`. The
workflow does not run tests; it only interprets reports.

### 5.5 Multi-repo / registry / index / safety

- `--workspace-roots="<path1>;<path2>;..."`
- `--repos-config=<path>`
- `--registry-dir=<path>`
- `--registry-roots="<path1>;<path2>;..."`
- `--index=<path>` / `--specindex=<path>`
- `--safety-mode=<normal|strict>`
  - `--strict` is a legacy alias.

Semantics:

- `--repos-config` is preferred for mapping spec-ids ↔ repos/apps.
- `--workspace-roots` is a discovery hint only.
- `--registry-dir` is primary registry root (default `.spec/registry`).
- `--registry-roots` are read-only supplemental registries.

### 5.6 Critical UI units (derivation rules)

To determine `criticality` for each UI unit, the workflow SHOULD:

1. **Consult registries (if available)**
   - UI/flows/critical-sections registries under `.spec/registry/`,
     e.g., entries marking flows as:
     - `business_critical`, `regulatory_critical`, `security_sensitive`.

2. **Inspect specs / UI JSON**
   - fields or tags such as:
     - `critical: true`, `importance: "high"`, `risk_level: "critical"`.
   - explicit labels like `checkout`, `payment`, `login`, `identity`,
     `consent`, `account_recovery` MAY be treated as **high priority**
     when combined with spec notation.

3. **Apply explicit overrides**
   - any `unit_id` listed in `--ui-critical-targets` MUST be treated as
     `critical`.

4. **Fallback behavior**
   - if no explicit information is present and unit is not in
     `--ui-critical-targets`, default `criticality` to `MEDIUM` or `LOW`
     based on local heuristics (e.g., route type), and record the
     uncertainty in `notes`.

Strict-mode blocking decisions (see 5.7) MUST primarily rely on
registries, spec tags, and `--ui-critical-targets`, not purely on
name-based guessing.

### 5.7 Safety-mode (normal vs strict)

**Normal (default)**

- Reports gaps & risks with recommendations.
- `blocking_for_release` mainly for units with `risk_level=CRITICAL`,
  especially when:
  - `accessibility_status=ISSUES_BLOCKING`, or
  - `behavior_validation_status=NONE/UNKNOWN` (for
    `criticality in {CRITICAL, HIGH}`), or
  - `spec_coverage_status=NONE/UNKNOWN` (for
    `criticality in {CRITICAL, HIGH}`), or
  - `cross_env_status=NONE/PARTIAL` where multiple target
    environments/devices are required by spec/flags.
  - `ui_json_quality_status=WEAK/BROKEN` for critical/high units.

**Strict (`--safety-mode=strict` / `--strict`)**

For units with `criticality in {CRITICAL, HIGH}` (from registries/specs
or `--ui-critical-targets`):

- If **any** of the following hold, then `blocking_for_release=true`
  (unless the unit is explicitly marked in specs as
  experimental/non-blocking with rationale):

  - `behavior_validation_status=NONE` or `behavior_validation_status=UNKNOWN`.
  - `spec_coverage_status=NONE` or `spec_coverage_status=UNKNOWN`.
  - `accessibility_status=ISSUES_BLOCKING`.
  - `visual_regression_status=NONE/UNKNOWN` for visually critical
    units (e.g., main landing, checkout, core data review views).
  - `i18n_status=NONE/UNKNOWN` where locales are required by
    policy/registries.
  - `cross_env_status=NONE/PARTIAL` when multiple target
    envs/browsers/devices are required and not covered.
  - `ui_spec_origin=AI` AND `ui_spec_review_status=UNREVIEWED`.
  - `ui_json_quality_status=WEAK` or `BROKEN`.
  - missing or inconsistent `design_system_version` or `style_preset`
    metadata where such metadata is required, especially when
    `--ui-json-ai-strict` is enabled.

For units with `criticality=MEDIUM`:

- may be blocking when combined statuses yield `risk_level=CRITICAL`,
  especially for flows with notable business impact.

For units with `criticality=LOW`:

- blocking is typically reserved for egregious accessibility,
  regulatory, or governance issues.

The workflow MUST explain each `blocking_for_release=true` decision in
`notes`.

### 5.8 Output control

- `--report-format=<md|json>`
  - default: `md`.

- `--report-dir=<path>`
  - default: `.spec/reports/smartspec_ui_validation/`.

- `--stdout-summary`
  - print a short summary.

### 5.9 Kilo / subtasks

- `--kilocode`
- `--nosubtasks`
  - disables Orchestrator auto-subtasking even under Kilo, but still
    follows the Orchestrator-per-task conceptual rule.

---

## 6) Canonical Folders & File Placement

The workflow MUST follow SmartSpec canonical layout:

1. **Index detection order (read-only)**:
   1) `.spec/SPEC_INDEX.json` (canonical)
   2) `SPEC_INDEX.json` at repo root (legacy)
   3) `.smartspec/SPEC_INDEX.json` (deprecated)
   4) `specs/SPEC_INDEX.json` (older layout)

2. **Specs & tasks**:
   - `specs/<category>/<spec-id>/spec.md`
   - `specs/<category>/<spec-id>/tasks.md`

3. **UI specs**:
   - if your SmartSpec base defines a canonical UI JSON location
     (e.g., a dedicated `.spec/ui/` directory or a standard
     `ui.json` file per spec), that MUST be used as primary.
   - `--ui-spec-paths` are then used to supplement or discover
     additional UI specs, not to override canonical conventions.

4. **Registries**:
   - primary: `.spec/registry/`.
   - supplemental (read-only): `--registry-roots`.

5. **Reports (outputs)**:
   - default root:
     `.spec/reports/smartspec_ui_validation/`.
   - file name pattern:
     `<timestamp>_<run-label>.{md|json}`.

The workflow MUST NOT create new top-level folders outside `.spec/`
by default.

---

## 7) Weakness & Risk Check (Quality Gate)

Before treating this workflow spec as complete, verify that it:

1. **Preserves NO-WRITE**
   - no changes to code, tests, configs, CI, or UI assets.
   - no running of browsers/tests.

2. **Separates validation vs design consistency**
   - focuses on behavior/coverage/a11y/i18n.
   - delegates design-tokens/spacing/pattern issues and AI UI JSON
     structural quality to `/smartspec_ui_consistency_audit` (but still
     reads `ui_json_quality_status` conceptually as part of risk).

3. **Respects JSON-first UI governance**
   - supports `--ui-json-mode` for auto/required/disabled modes.
   - does not silently ignore missing UI JSON when `required`.
   - does not propose new UI JSON locations that conflict with
     canonical layout.

4. **Uses status model consistently**
   - populates per-unit statuses using defined enums.
   - avoids inventing arbitrary labels.
   - keeps JSON as canonical structure; ensures markdown reports
     include all fields.

5. **Accounts for multi-env/platform**
   - uses `target-envs`, `target-browsers`, `target-devices`, and any
     registry information about required platforms to assess
     `cross_env_status`.
   - raises risk when coverage is partial across required platforms.

6. **Protects sensitive data**
   - does not embed real user data, secrets, tokens, or full
     identifiers in reports.
   - encourages teams to avoid using production data or unsanitized
     PII in UI test snapshots and reports.

7. **Handles AI-generated UI JSON explicitly**
   - uses `ui_spec_origin`, `ui_spec_review_status`, and
     `ui_json_quality_status` as first-class signals.
   - treats unreviewed AI-generated specs for critical/high flows as
     elevated risk, especially with `--ui-json-ai-strict`.

8. **Provides clear blocking rules**
   - especially under strict mode for critical/high flows.
   - explains blocking decisions in `notes`.

9. **Maintains governance-only boundary**
   - does not output ready-to-run test scripts as implicitly approved.
   - may describe missing test patterns conceptually.

10. **Incorporates web-stack security & dependency evidence**
    - when UI implementation uses React/Next.js/RSC or similar web stacks,
      the workflow reads available security/dependency evidence (e.g.,
      SCA reports, dependency snapshots, `tool-version-registry.json`) and
      reflects missing or outdated evidence in `risk_level` and
      `blocking_for_release` for critical/high units, especially under
      strict safety mode.

---

## 8) Legacy Flags Inventory

This workflow is an evolution of `/smartspec_ui_validation` in the
5.6.x family.

- **Kept as-is**:
  - all previously documented flags and semantics.

- **Legacy alias**:
  - `--strict` → alias for `--safety-mode=strict`.

- **New additive flags in v5.6.3**:
  - `--ui-json-ai-strict`.

- **New additive flags in v5.6.4**:
  - _none_ (this release adds governance clarifications only; no new
    flags or behavior changes for existing flags).

All other flags from earlier 5.6.x revisions remain valid and
unchanged.

---

## 9) KiloCode Support (Meta-Flag)

As a verification/governance workflow:

- accepts `--kilocode`.
- role under Kilo: **Ask / Architect**, **NO-WRITE**.
- default under Kilo: **subtasks ON**, unless `--nosubtasks` is set.
- must follow the **Kilo Orchestrator-per-task rule**.

### 9.1 Orchestrator loop (Kilo + subtasks)

For each spec-id or UI flow group:

1. Orchestrator gathers:
   - UI spec + UI JSON + meta (including AI origin, review status,
     design system version, style preset).
   - mapping to implementation.
   - relevant test and report artifacts.
2. Code mode (read-only) parses reports and builds per-unit statuses.
3. Orchestrator aggregates per-unit results and summary by scope.

### 9.2 Non-Kilo environments

- treat `--kilocode` as no-op.
- perform equivalent logic in a single reasoning flow.

---

## 10) Inline Detection Rules

The workflow must not call other SmartSpec workflows for detection.
Instead, it:

1. inspects environment/system prompts for Kilo/ClaudeCode/Antigravity
   markers.
2. checks for `--kilocode`.
3. if ambiguous, defaults to tool-agnostic behavior and may record this
   in the report header.

---

## 11) Multi-repo / Multi-registry Rules

1. Use `--repos-config` to map spec-ids to apps/repos (web, mobile,
   etc.).
2. Use `--workspace-roots` only as a discovery hint, never to invent
   spec-ids outside SPEC_INDEX.
3. Use registries (UI/flows, critical-sections, SLOs) to:
   - locate UI responsibilities across services/apps.
   - identify critical flows and business-critical screens.
4. For cross-app flows:
   - list all involved apps/targets.
   - note where validation is missing in parts of the flow.

---

## 12) UI Addendum (JSON-first, AI-generated)

This workflow is UI-centric and must respect UI governance:

1. **JSON-first UI projects**
   - treat UI JSON as the primary UI spec.
   - if `--ui-json-mode=required`:
     - missing or incomplete UI JSON for a screen/flow is a validation
       gap and influences `spec_coverage_status`,
       `ui_json_quality_status`, and `risk_level`.
   - do not invent new UI JSON shapes that conflict with existing
     canonical definitions.

2. **AI-generated UI JSON metadata**
   - when `meta.source=ai` and/or `meta.generator` indicates AI:
     - record `ui_spec_origin=AI`.
     - if `meta.review_status=unreviewed` → `ui_spec_review_status=UNREVIEWED`.
   - expect `meta.design_system_version` and `meta.style_preset` to
     match design system registries where applicable.
   - missing or inconsistent metadata for critical/high flows should
     raise `risk_level` and may trigger `blocking_for_release` in
     strict mode, especially when `--ui-json-ai-strict` is enabled.

3. **Inline UI / opt-out**
   - when `--ui-json-mode=disabled`:
     - do not assume UI JSON exists.
     - rely on markdown specs, tasks, and other docs.
     - still apply the same status model per UI unit.

4. **Modern UI expectations**
   - ensure validation checks note:
     - responsive behavior where relevant.
     - accessibility cues (landmarks, ARIA usage, keyboard navigation).
     - error/validation messages that align with spec and UX guidance.
   - the workflow does NOT replace designers; it checks that the
     implemented and tested behavior matches the intended UX.

---

## 13) Best Practices (for Users)

- Maintain up-to-date UI specs and (if applicable) UI JSON, including
  `meta` fields for AI-generated specs.
- Run UI tests in CI and archive reports where this workflow can read
  them.
- Avoid using production data or unsanitized PII in UI test snapshots
  and reports; prefer synthetic or masked data.
- Use this workflow:
  - before major releases.
  - when migrating UI frameworks or rewriting key flows.
  - after large-scale AI regeneration of `ui.json`.
- Enable `--safety-mode=strict` and `--ui-json-ai-strict` for:
  - critical user flows (checkout, login, identity, consent).
  - regulated UI domains (e.g., legal consent flows).
- Combine with:
  - `/smartspec_ui_consistency_audit` for design system adherence and
    AI UI JSON quality.
  - `/smartspec_release_readiness` for overall release gates.
  - security / dependency workflows and CI gates that interpret
    React/Next.js/RSC and npm dependency baselines alongside this
    UI-validation report.
- Keep validation reports under version control as part of release
  artifacts.

---

## 14) For the LLM / Step-by-Step Flow & Stop Conditions

### 14.1 Step-by-step flow

1. **Resolve scope**
   - parse `--spec-ids`, `--ui-targets`, `--ui-critical-targets`,
     `--include-dependencies`, `--run-label`, `--ui-json-mode`,
     `--ui-json-ai-strict`, `--target-*`.
   - load SPEC_INDEX in canonical order.
   - validate spec-ids and discover UI specs/docs.

2. **Gather artifacts**
   - load specs/tasks for scoped spec-ids.
   - load UI specs/JSON from canonical locations and `--ui-spec-paths`.
   - read UI JSON meta when present.
   - load UI implementation hints from `--ui-impl-paths`.
   - load test reports from:
     - `--ui-test-report-paths`
     - `--ui-snapshot-report-paths`
     - `--ui-accessibility-report-paths`
     - `--ui-i18n-report-paths`.
   - load registries (UI/flows, critical-sections, SLOs, and when
     available `tool-version-registry.json` and design-system registries)
     to infer critical flows and relevant governance baselines.

3. **Identify UI units & criticality**
   - derive screens/routes/flows from UI specs/JSON + SPEC_INDEX.
   - if `--ui-targets` provided, limit to those units.
   - map units to implementation as best as possible.
   - determine `criticality` per unit using rules in 5.6 and
     `--ui-critical-targets`.
   - derive `ui_spec_origin`, `ui_spec_review_status`, and initial
     `ui_json_quality_status` from UI JSON meta and structure.

4. **Compute per-unit statuses**
   - using reports and docs, fill:
     - `spec_coverage_status`
     - `behavior_validation_status`
     - `error_state_coverage_status`
     - `input_validation_coverage_status`
     - `accessibility_status`
     - `visual_regression_status`
     - `i18n_status`
     - `cross_env_status`
   - refine `ui_json_quality_status` based on how well tests align with
     the structure and expectations in UI JSON.
   - where UI is implemented with React/Next.js/RSC or similar web
     stacks, interpret available security/dependency evidence
     (e.g., SCA reports, dependency baselines, known high-severity
     advisories, `tool-version-registry.json`) and reflect gaps in
     `risk_level` and `blocking_for_release`, especially for
     critical/high units under strict mode.
   - infer `risk_level` and `blocking_for_release` using safety-mode
     rules, `criticality`, AI-origin signals, and security/dependency
     evidence.

5. **Aggregate**
   - compute unit counts by `risk_level` and `blocking_for_release`.
   - highlight high-risk / blocking units, especially critical flows
     with unreviewed AI-generated UI JSON or missing security/dependency
     evidence for web stacks in scope.

6. **Generate report**
   - serialize per-unit data and summary to `.md` or `.json` in
     `--report-dir`.
   - ensure markdown representation mirrors the JSON field set.
   - include minimal audit metadata (workflow version, key flags,
     presence/absence of tool-version and design-system registries).

7. **Optional stdout summary**
   - if `--stdout-summary`, print:
     - number of units.
     - number of blocking units.
     - list of top-risk units.

### 14.2 Stop conditions

The workflow MUST stop after:

- writing (or simulating writing) the validation report, and
- printing any optional stdout summary.

It MUST NOT:

- modify code, tests, configs, or CI.
- run UI tests or browsers/devices.
- call other SmartSpec workflows directly (only reference them as
  recommendations).

---

## 15) Security & Dependency Guardrails (Web/React/Next.js/RSC)

This section clarifies how `/smartspec_ui_validation` interacts with
modern web-stack security and dependency governance while remaining
**NO-WRITE** and UI-validation focused.

1. **Detection & scope**

   - When evidence suggests the UI implementation uses:
     - React or React-based frameworks (e.g., Next.js), and/or
     - SSR/Edge runtimes, server actions, or React Server Components
       (RSC), and/or
     - `react-server-dom-*` dependencies, and/or
     - Node/npm-based dependency trees,

     the workflow MUST treat these as in-scope for **security &
     dependency risk signals**, in alignment with central security and
     tool-version policies.

2. **Evidence, not execution**

   - This workflow:
     - MUST NOT run dependency commands (e.g., `npm audit`, test
       runners).
     - MAY read existing security/dependency artifacts, such as:
       - SCA/vulnerability reports,
       - dependency snapshots or lockfile summaries,
       - CI security gate summaries,
       - `.spec/registry/tool-version-registry.json` entries for
         React/ReactDOM/Next.js/Node or equivalents.
   - Missing evidence for critical/high UI units SHOULD be reflected as
     elevated `risk_level` and may contribute to
     `blocking_for_release=true` in strict mode.

3. **High-risk RSC / `react-server-dom-*`**

   - If the project uses RSC or any `react-server-dom-*` dependency:
     - treat this surface as **high risk** by default.
     - require evidence (via reports/registries) that:
       - RSC-related packages/frameworks are at or above the
         organization’s minimum patched baselines for known critical
         CVEs;
       - data flowing across the RSC boundary has been reviewed for
         leakage or unsafe serialization.
     - For critical/high UI units, absence of such evidence SHOULD
       raise `risk_level` and, under strict mode, may set
       `blocking_for_release=true` with explanation in `notes`.

4. **React/Next.js without RSC**

   - For React/Next.js projects without RSC:
     - highlight gaps in:
       - routing/middleware hardening,
       - auth/session handling visible at the UI level,
       - SSR/Edge behavior where applicable,
       - npm supply-chain hygiene.
     - The workflow relies on existing security reports and registry
       policies to infer whether these concerns have been addressed.
     - For critical/high units, clear evidence of unresolved
       high-severity vulnerabilities in UI-facing services SHOULD
       contribute to higher `risk_level`.

5. **Tool version registry & CVE baselines**

   - When `.spec/registry/tool-version-registry.json` is present:
     - treat it as authoritative for minimum patched versions and
       allowed series for React/ReactDOM/Next.js/Node and related
       tools.
     - if a UI unit’s implementation falls below the registry’s
       baselines (as indicated by reports or dependency summaries),
       reflect this in `risk_level` and, for critical/high units under
       strict mode, consider it blocking until an exception is
       documented elsewhere.
   - When the registry is missing:
     - do not fail; instead, record the absence as a governance gap in
       the report summary and encourage follow-up security workflows to
       establish the registry.

6. **Dependency hygiene & CI gates**

   - The workflow SHOULD:
     - look for evidence of:
       - lockfiles (e.g., `package-lock.json`, `yarn.lock`,
         `pnpm-lock.yaml`),
       - regular SCA/dependency scans in CI,
       - automated update tooling (e.g., Dependabot, Renovate) for
         UI-related services.
     - treat missing or clearly outdated dependency governance as a
       contributing factor to higher `risk_level`, especially in
       strict mode for critical/high UI units.
   - It MUST clearly separate these signals from functional UI tests
     and MUST NOT imply that dependencies are safe solely because UI
     tests are passing.

7. **Safer UI/server integration patterns**

   - When reviewing evidence, the workflow SHOULD flag (via `notes`
     and `risk_level` only) patterns such as:
     - unreviewed usage of unsafe HTML injection (e.g.,
       `dangerouslySetInnerHTML` in React) in critical/high units;
     - embedding secrets, tokens, or sensitive internal URLs in
       client bundles or `ui.json`;
     - bypassing framework CSRF/XSS protections at UI boundaries.
   - It MAY recommend (conceptually) remediation patterns but MUST NOT
     emit ready-to-run code patches.

---

## 16) Design-System & Component-Registry Alignment

This section clarifies how `/smartspec_ui_validation` respects design
systems and component registries while still delegating visual/style
enforcement to `/smartspec_ui_consistency_audit`.

1. **Design tokens & registries**

   - When `.spec/registry/design-tokens-registry.json`,
     `ui-component-registry.json`, `app-component-registry.json`, or
     `patterns-registry.json` exist:
     - treat them as **governance inputs** that describe intended UI
       structure and component usage.
     - do not validate exact colors/spacing/visual patterns here
       (delegated to UI consistency workflows), but:
       - use them to understand which components and layout patterns
         are expected for each UI unit.
       - note when critical/high units appear to rely heavily on
         raw library components instead of app-level components where
         the registry suggests otherwise.

2. **App-level components vs raw library components**

   - Where registries define App-level components (e.g., `AppButton`,
     `AppCard`, `AppInput`, `AppEmptyState`, `AppErrorState`,
     `AppSectionHeader`):
     - prefer these as the primary conceptual UI API when interpreting
       UI JSON and implementation reports.
     - if critical/high UI units appear (from reports or mappings) to
       use raw library components directly (e.g., MUI `Button`,
       `TextField`) instead of App-level wrappers, treat that as a
       **risk signal for maintainability and consistency**, not a
       visual bug.
     - reflect such drift in `notes` and optionally modestly raise
       `risk_level`, especially when combined with weak validation
       coverage.

3. **Layout patterns & states**

   - For projects with patterns defined (e.g., workspace layouts, AI
     run views, standard empty/loading/error states):
     - interpret UI specs/UI JSON and implementation mappings in the
       context of these patterns.
     - flag in `notes` when critical/high UI units:
       - lack defined loading/empty/error states, or
       - diverge from required layout patterns in ways that are likely
         to reduce usability or create untested states.
   - The workflow SHOULD ensure that validation coverage considers
     these states; e.g., missing tests for critical empty/error states
     should lower `error_state_coverage_status` and raise
     `risk_level`.

4. **Separation of concerns with `/smartspec_ui_consistency_audit`**

   - `/smartspec_ui_validation`:
     - focuses on behavior, states, and coverage for each UI unit.
     - uses design-system and component registries as **context** to
       interpret risks and missing coverage.
   - `/smartspec_ui_consistency_audit`:
     - focuses on design-token usage, spacing, visual coherence,
       component/theming consistency, and AI UI JSON structural
       quality.
   - Reports from this workflow MAY include recommendations to run or
     re-run `/smartspec_ui_consistency_audit` when design-system
     misalignment appears to amplify the risk of unvalidated behavior.

5. **AI-product UIs & modern look**

   - For AI/workflow-centric UIs (e.g., smart workspaces, run viewers),
     where design tokens and patterns prioritize modern layouts:
     - treat lack of validation for key states (e.g., prompt errors,
       model changes, diff/compare views) as a validation gap.
     - ensure that such gaps for critical/high UI units show up in
       `error_state_coverage_status`, `behavior_validation_status`,
       and `risk_level` rather than as purely cosmetic issues.

---

