"use strict";
/**
 * Auth Controller
 *
 * Handles authentication endpoints
 * Generated by SmartSpec Auth Generator
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthController = void 0;
const zod_1 = require("zod");
// Validation schemas
const registerSchema = zod_1.z.object({
    email: zod_1.z.string().email('Invalid email format'),
    password: zod_1.z.string().min(8, 'Password must be at least 8 characters'),
    // Add additional fields from user model here if needed
});
const loginSchema = zod_1.z.object({
    email: zod_1.z.string().email('Invalid email format'),
    password: zod_1.z.string().min(1, 'Password is required'),
});
const refreshTokenSchema = zod_1.z.object({
    refreshToken: zod_1.z.string().min(1, 'Refresh token is required'),
});
const resetPasswordRequestSchema = zod_1.z.object({
    email: zod_1.z.string().email('Invalid email format'),
});
const resetPasswordSchema = zod_1.z.object({
    token: zod_1.z.string().min(1, 'Reset token is required'),
    newPassword: zod_1.z.string().min(8, 'Password must be at least 8 characters'),
});
const changePasswordSchema = zod_1.z.object({
    currentPassword: zod_1.z.string().min(1, 'Current password is required'),
    newPassword: zod_1.z.string().min(8, 'Password must be at least 8 characters'),
});
class AuthController {
    constructor(authService) {
        this.authService = authService;
    }
    /**
     * Register new user
     * POST /auth/register
     */
    async register(req, res, next) {
        try {
            // Validate input
            const input = registerSchema.parse(req.body);
            // Register user
            const result = await this.authService.register(input);
            res.status(201).json({
                success: true,
                data: {
                    user: result.user,
                    tokens: result.tokens,
                },
                message: 'Registration successful. Please check your email to verify your account',
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Login user
     * POST /auth/login
     */
    async login(req, res, next) {
        try {
            // Validate input
            const input = loginSchema.parse(req.body);
            // Find user by email (this would be done by the database layer)
            // For now, we'll assume the user is passed from middleware
            const user = req.user;
            if (!user) {
                res.status(401).json({
                    success: false,
                    error: 'Invalid credentials',
                });
                return;
            }
            // Login
            const result = await this.authService.login(input, user);
            res.status(200).json({
                success: true,
                data: {
                    user: result.user,
                    tokens: result.tokens,
                },
                message: 'Login successful',
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Refresh tokens
     * POST /auth/refresh
     */
    async refreshTokens(req, res, next) {
        try {
            // Validate input
            const { refreshToken } = refreshTokenSchema.parse(req.body);
            // Get user from token (this would be done by middleware)
            const user = req.user;
            if (!user) {
                res.status(401).json({
                    success: false,
                    error: 'Invalid refresh token',
                });
                return;
            }
            // Refresh tokens
            const tokens = await this.authService.refreshTokens(refreshToken, user);
            res.status(200).json({
                success: true,
                data: { tokens },
                message: 'Tokens refreshed successfully',
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Verify email
     * GET /auth/verify-email/:token
     */
    async verifyEmail(req, res, next) {
        try {
            const { token } = req.params;
            // Get user from database
            const user = req.user;
            if (!user) {
                res.status(404).json({
                    success: false,
                    error: 'User not found',
                });
                return;
            }
            // Verify email
            await this.authService.verifyEmail(token, user);
            res.status(200).json({
                success: true,
                message: 'Email verified successfully',
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Request password reset
     * POST /auth/forgot-password
     */
    async requestPasswordReset(req, res, next) {
        try {
            // Validate input
            const { email } = resetPasswordRequestSchema.parse(req.body);
            // Request password reset
            const resetToken = await this.authService.requestPasswordReset(email);
            // In production, send email with reset link
            // For now, return token in response (NOT SECURE - for development only)
            res.status(200).json({
                success: true,
                message: 'Password reset email sent',
                // Remove this in production:
                data: { resetToken },
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Reset password
     * POST /auth/reset-password
     */
    async resetPassword(req, res, next) {
        try {
            // Validate input
            const { token, newPassword } = resetPasswordSchema.parse(req.body);
            // Get user from database
            const user = req.user;
            if (!user) {
                res.status(404).json({
                    success: false,
                    error: 'Invalid or expired reset token',
                });
                return;
            }
            // Reset password
            await this.authService.resetPassword(token, newPassword, user);
            res.status(200).json({
                success: true,
                message: 'Password reset successfully',
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Change password (authenticated)
     * POST /auth/change-password
     */
    async changePassword(req, res, next) {
        try {
            // Validate input
            const { currentPassword, newPassword } = changePasswordSchema.parse(req.body);
            // Get authenticated user
            const user = req.user;
            if (!user) {
                res.status(401).json({
                    success: false,
                    error: 'Unauthorized',
                });
                return;
            }
            // Change password
            await this.authService.changePassword(user, currentPassword, newPassword);
            res.status(200).json({
                success: true,
                message: 'Password changed successfully',
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Get current user
     * GET /auth/me
     */
    async getCurrentUser(req, res, next) {
        try {
            const user = req.user;
            if (!user) {
                res.status(401).json({
                    success: false,
                    error: 'Unauthorized',
                });
                return;
            }
            // Remove password from response
            const { password, ...userWithoutPassword } = user;
            res.status(200).json({
                success: true,
                data: { user: userWithoutPassword },
            });
        }
        catch (error) {
            next(error);
        }
    }
    /**
     * Logout
     * POST /auth/logout
     */
    async logout(req, res, next) {
        try {
            // In production, add token to blacklist
            // For now, just return success
            res.status(200).json({
                success: true,
                message: 'Logout successful',
            });
        }
        catch (error) {
            next(error);
        }
    }
}
exports.AuthController = AuthController;
//# sourceMappingURL=auth.controller.js.map