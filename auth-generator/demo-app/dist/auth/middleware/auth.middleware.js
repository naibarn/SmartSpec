"use strict";
/**
 * Auth Middleware
 *
 * JWT verification and authorization middleware
 * Generated by SmartSpec Auth Generator
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthMiddleware = void 0;
exports.createAuthMiddleware = createAuthMiddleware;
class AuthMiddleware {
    constructor(jwtService) {
        /**
         * Verify JWT token and attach user to request
         */
        this.authenticate = async (req, res, next) => {
            try {
                // Get token from header
                const authHeader = req.headers.authorization;
                if (!authHeader || !authHeader.startsWith('Bearer ')) {
                    res.status(401).json({
                        success: false,
                        error: 'No token provided',
                    });
                    return;
                }
                const token = authHeader.substring(7); // Remove 'Bearer ' prefix
                // Verify token
                const payload = await this.jwtService.verifyAccessToken(token);
                // Get user from database (this would be done by the database layer)
                // For now, we'll assume the user is retrieved and attached
                // In production, you would query the database here:
                // const user = await userRepository.findById(payload.userId);
                // Attach user to request
                req.user = {
                    id: payload.userId,
                    email: payload.email,
                    role: payload.role,
                    // Other user fields would be populated from database
                };
                next();
            }
            catch (error) {
                res.status(401).json({
                    success: false,
                    error: 'Invalid or expired token',
                });
            }
        };
        /**
         * Check if user has required role
         */
        this.requireRole = (allowedRoles) => {
            return async (req, res, next) => {
                try {
                    const user = req.user;
                    if (!user) {
                        res.status(401).json({
                            success: false,
                            error: 'Unauthorized',
                        });
                        return;
                    }
                    if (!allowedRoles.includes(user.role)) {
                        res.status(403).json({
                            success: false,
                            error: 'Insufficient permissions',
                        });
                        return;
                    }
                    next();
                }
                catch (error) {
                    next(error);
                }
            };
        };
        /**
         * Optional authentication - attach user if token is valid, but don't fail if not
         */
        this.optionalAuth = async (req, res, next) => {
            try {
                const authHeader = req.headers.authorization;
                if (!authHeader || !authHeader.startsWith('Bearer ')) {
                    next();
                    return;
                }
                const token = authHeader.substring(7);
                const payload = await this.jwtService.verifyAccessToken(token);
                req.user = {
                    id: payload.userId,
                    email: payload.email,
                    role: payload.role,
                };
                next();
            }
            catch (error) {
                // Token invalid, but that's okay for optional auth
                next();
            }
        };
        /**
         * Check if account is locked
         */
        this.checkAccountLockout = async (req, res, next) => {
            try {
                const user = req.user;
                if (!user) {
                    next();
                    return;
                }
                // Check if account is locked
                if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {
                    const remainingMinutes = Math.ceil((new Date(user.lockedUntil).getTime() - Date.now()) / 60000);
                    res.status(423).json({
                        success: false,
                        error: `Account is locked. Try again in ${remainingMinutes} minutes`,
                    });
                    return;
                }
                next();
            }
            catch (error) {
                next(error);
            }
        };
        /**
         * Require email verification
         */
        this.requireEmailVerified = async (req, res, next) => {
            try {
                const user = req.user;
                if (!user) {
                    res.status(401).json({
                        success: false,
                        error: 'Unauthorized',
                    });
                    return;
                }
                if (!user.emailVerified) {
                    res.status(403).json({
                        success: false,
                        error: 'Email not verified. Please verify your email first',
                    });
                    return;
                }
                next();
            }
            catch (error) {
                next(error);
            }
        };
        this.jwtService = jwtService;
    }
}
exports.AuthMiddleware = AuthMiddleware;
/**
 * Helper to create middleware instance
 */
function createAuthMiddleware(jwtService) {
    return new AuthMiddleware(jwtService);
}
//# sourceMappingURL=auth.middleware.js.map