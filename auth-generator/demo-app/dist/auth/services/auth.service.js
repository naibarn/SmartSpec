"use strict";
/**
 * Auth Service (Generated Template)
 *
 * This is a template that shows the structure.
 * The actual implementation is in src/services/auth.service.ts
 * Generated by SmartSpec Auth Generator
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const auth_types_1 = require("../types/auth.types");
class AuthService {
    constructor(jwtService, passwordService) {
        this.jwtService = jwtService;
        this.passwordService = passwordService;
    }
    /**
     * Register new user
     */
    async register(input) {
        // 1. Validate password strength
        const passwordValidation = this.passwordService.validatePasswordStrength(input.password);
        if (!passwordValidation.isValid) {
            throw auth_types_1.AUTH_ERRORS.WEAK_PASSWORD;
        }
        // 2. Check if user exists (database layer)
        // const existingUser = await userRepository.findByEmail(input.email);
        // if (existingUser) throw AUTH_ERRORS.USER_EXISTS;
        // 3. Hash password
        const hashedPassword = await this.passwordService.hashPassword(input.password);
        // 4. Create user (database layer)
        const user = {
            id: 'generated-id', // Would be generated by database
            email: input.email,
            password: hashedPassword,
            role: UserRole.USER,
            emailVerified: false,
            failedLoginAttempts: 0,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        // 5. Generate tokens
        const tokens = await this.jwtService.generateTokenPair({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
        // 6. Remove password from response
        const { password, ...publicUser } = user;
        return {
            user: publicUser,
            tokens,
        };
    }
    /**
     * Login user
     */
    async login(input, user) {
        // Check if account is locked
        if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {
            throw auth_types_1.AUTH_ERRORS.ACCOUNT_LOCKED;
        }
        // Verify password
        const isValid = await this.passwordService.verifyPassword(input.password, user.password);
        if (!isValid) {
            // Increment failed attempts
            user.failedLoginAttempts = (user.failedLoginAttempts || 0) + 1;
            // Lock account if max attempts reached
            if (user.failedLoginAttempts >= 5) {
                user.lockedUntil = new Date(Date.now() + 30 * 60 * 1000);
            }
            // Save user (database layer)
            // await userRepository.update(user);
            throw auth_types_1.AUTH_ERRORS.INVALID_CREDENTIALS;
        }
        // Reset failed attempts on successful login
        if (user.failedLoginAttempts > 0) {
            user.failedLoginAttempts = 0;
            user.lockedUntil = undefined;
            // await userRepository.update(user);
        }
        // Generate tokens
        const tokens = await this.jwtService.generateTokenPair({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
        const { password, ...publicUser } = user;
        return {
            user: publicUser,
            tokens,
        };
    }
    /**
     * Refresh tokens
     */
    async refreshTokens(refreshToken, user) {
        // Verify refresh token
        const payload = await this.jwtService.verifyRefreshToken(refreshToken);
        // Verify user matches token
        if (payload.userId !== user.id) {
            throw auth_types_1.AUTH_ERRORS.INVALID_TOKEN;
        }
        // Generate new token pair
        return this.jwtService.generateTokenPair({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
    }
    /**
     * Verify email
     */
    async verifyEmail(token, user) {
        if (user.emailVerificationToken !== token) {
            throw auth_types_1.AUTH_ERRORS.INVALID_TOKEN;
        }
        if (user.emailVerificationExpires && new Date(user.emailVerificationExpires) < new Date()) {
            throw auth_types_1.AUTH_ERRORS.INVALID_TOKEN;
        }
        user.emailVerified = true;
        user.emailVerificationToken = undefined;
        user.emailVerificationExpires = undefined;
        // Save user (database layer)
        // await userRepository.update(user);
    }
    /**
     * Request password reset
     */
    async requestPasswordReset(email) {
        // Find user (database layer)
        // const user = await userRepository.findByEmail(email);
        // if (!user) throw AUTH_ERRORS.USER_NOT_FOUND;
        // Generate reset token
        const resetToken = this.generateSecureToken();
        // Set token expiry (1 hour)
        const resetExpires = new Date(Date.now() + 60 * 60 * 1000);
        // Save token (database layer)
        // user.resetPasswordToken = resetToken;
        // user.resetPasswordExpires = resetExpires;
        // await userRepository.update(user);
        return resetToken;
    }
    /**
     * Reset password
     */
    async resetPassword(token, newPassword, user) {
        if (user.resetPasswordToken !== token) {
            throw auth_types_1.AUTH_ERRORS.INVALID_TOKEN;
        }
        if (user.resetPasswordExpires && new Date(user.resetPasswordExpires) < new Date()) {
            throw auth_types_1.AUTH_ERRORS.INVALID_TOKEN;
        }
        // Validate new password
        const validation = this.passwordService.validatePasswordStrength(newPassword);
        if (!validation.isValid) {
            throw auth_types_1.AUTH_ERRORS.WEAK_PASSWORD;
        }
        // Hash new password
        const hashedPassword = await this.passwordService.hashPassword(newPassword);
        user.password = hashedPassword;
        user.resetPasswordToken = undefined;
        user.resetPasswordExpires = undefined;
        // Save user (database layer)
        // await userRepository.update(user);
    }
    /**
     * Change password (authenticated user)
     */
    async changePassword(user, currentPassword, newPassword) {
        // Verify current password
        const isValid = await this.passwordService.verifyPassword(currentPassword, user.password);
        if (!isValid) {
            throw auth_types_1.AUTH_ERRORS.INVALID_CREDENTIALS;
        }
        // Validate new password
        const validation = this.passwordService.validatePasswordStrength(newPassword);
        if (!validation.isValid) {
            throw auth_types_1.AUTH_ERRORS.WEAK_PASSWORD;
        }
        // Hash new password
        const hashedPassword = await this.passwordService.hashPassword(newPassword);
        user.password = hashedPassword;
        // Save user (database layer)
        // await userRepository.update(user);
    }
    /**
     * Generate secure random token
     */
    generateSecureToken() {
        return require('crypto').randomBytes(32).toString('hex');
    }
}
exports.AuthService = AuthService;
//# sourceMappingURL=auth.service.js.map