# Template Usage Guide

**Version:** 1.0.0  
**Last Updated:** December 27, 2025

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [Template Basics](#2-template-basics)
3. [Built-in Templates](#3-built-in-templates)
4. [Handlebars Helpers](#4-handlebars-helpers)
5. [Template Context Reference](#5-template-context-reference)
6. [Creating Custom Templates](#6-creating-custom-templates)
7. [Template Examples](#7-template-examples)
8. [Framework Integration](#8-framework-integration)
9. [Template Debugging](#9-template-debugging)
10. [Template Variants](#10-template-variants)
11. [Advanced Topics](#11-advanced-topics)
12. [Best Practices](#12-best-practices)
13. [Appendix](#13-appendix)

---

## 1. Introduction

### What are Templates?

Templates are Handlebars files that define the structure and content of generated code. Each template corresponds to a specific component of the authentication system, such as controllers, middleware, services, types, or routes. Templates use placeholders and conditional logic to generate code that matches your specification requirements.

The template system provides a powerful way to customize code generation while maintaining consistency across projects. Templates can include conditional blocks that render different code based on features enabled in your specification, iteration over collections like roles and endpoints, helper functions for string manipulation and formatting, and nested logic for complex code structures.

### Why Use Templates?

Templates offer several key advantages over manual code writing. They ensure consistency across your codebase by generating uniform code structure and naming conventions. Templates are reusable across multiple projects, saving development time. They reduce errors by eliminating manual typing and copy-paste mistakes. Templates are customizable, allowing you to adapt generated code to your specific needs while maintaining the benefits of automation.

### Template Engine (Handlebars)

Auth Generator uses Handlebars as its template engine. Handlebars is a popular, logic-less templating language that extends Mustache with additional features. It provides a clean syntax for variable interpolation, conditional rendering, iteration, and custom helpers. The logic-less philosophy keeps templates simple and maintainable while still providing powerful functionality through helpers.

### Template Architecture

The template system follows a modular architecture where each component type has its own template file. Templates are organized in a directory structure that mirrors the output structure. The generator loads templates at initialization, compiles them using Handlebars, prepares context data from the parsed specification, renders each template with the context, and writes the generated code to the output directory.

```
templates/auth/
├── controllers/
│   └── auth.controller.ts.hbs
├── middleware/
│   └── auth.middleware.ts.hbs
├── types/
│   └── auth.types.ts.hbs
├── routes/
│   └── auth.routes.ts.hbs
└── services/
    └── auth.service.ts.hbs
```

---

## 2. Template Basics

### 2.1 Template Structure

Templates follow a consistent structure that makes them easy to understand and modify. Each template begins with a comment block describing its purpose and the component it generates. The template then includes necessary imports, followed by the main component definition with conditional sections based on features, and concludes with exports.

A typical template structure looks like this:

```handlebars
/**
 * {{capitalize type}}
 * 
 * {{description}}
 * Generated by SmartSpec Auth Generator
 */

{{! Imports }}
import { ... } from '...';

{{! Main component }}
export class {{pascalCase name}} {
  {{#if features.someFeature}}
  // Feature-specific code
  {{/if}}
}
```

### 2.2 Template Syntax

Handlebars provides several syntax constructs for building templates.

**Variables** are inserted using double curly braces. The value is HTML-escaped by default, though this doesn't affect TypeScript code generation.

```handlebars
{{variableName}}
{{object.property}}
{{array.[0]}}
```

**Comments** use Handlebars comment syntax and are not included in the generated output.

```handlebars
{{! This is a comment }}
{{!-- Multi-line comment
     can span multiple lines --}}
```

**Blocks** provide conditional rendering and iteration capabilities.

```handlebars
{{#if condition}}
  Content when true
{{else}}
  Content when false
{{/if}}

{{#each array}}
  {{this.property}}
{{/each}}

{{#unless condition}}
  Content when false
{{/unless}}
```

**Partials** allow you to include reusable template fragments, though the current implementation doesn't use partials extensively.

```handlebars
{{> partialName}}
{{> partialName context}}
```

### 2.3 Context Data

The context is a JavaScript object containing all data needed to render the template. It includes information extracted from your specification such as enabled features, RBAC configuration, JWT settings, security settings, user model fields, and endpoint definitions.

Templates access context data using dot notation:

```handlebars
{{features.emailVerification}}
{{rbac.defaultRole}}
{{securitySettings.passwordRequirements.minLength}}
{{#each rbac.roles}}
  {{this.name}}
{{/each}}
```

The context structure is consistent across all templates, ensuring that templates can access the same data regardless of which component they're generating.

---

## 3. Built-in Templates

### 3.1 Controller Template

**Location:** `templates/auth/controllers/auth.controller.ts.hbs`

**Purpose:** Generates the authentication controller with endpoints for registration, login, token refresh, and optional features like email verification and password reset.

**Available Context:**

The controller template has access to the complete context including features configuration (emailVerification, passwordReset, accountLockout), security settings for password validation and account lockout, RBAC configuration for role-based endpoints, and user model fields for registration validation.

**Generated Output:**

The controller template generates a TypeScript class with the following structure. It includes a constructor that initializes the auth service, endpoint methods for each authentication operation, Zod validation schemas for request bodies, error handling with try-catch blocks, and proper HTTP status codes and response formats.

**Key Endpoints:**

The `register` endpoint creates new user accounts with password validation and optional email verification. The `login` endpoint authenticates users and returns JWT tokens, with optional account lockout checking. The `refresh` endpoint generates new access tokens from refresh tokens. The `verifyEmail` endpoint confirms email addresses (conditional on emailVerification feature). The `requestPasswordReset` and `resetPassword` endpoints handle password recovery (conditional on passwordReset feature). The `changePassword` endpoint allows authenticated users to update their passwords. The `me` endpoint returns the current user's profile. The `logout` endpoint invalidates tokens (with optional token blacklist).

**Customization Points:**

You can customize validation schemas to add custom fields or rules, modify response formats to match your API conventions, add custom endpoints for application-specific auth operations, change error handling to use your preferred error format, and adjust middleware usage for custom authentication flows.

**Example Usage:**

```typescript
// Generated controller
import { AuthController } from './controllers/auth.controller';

const authController = new AuthController();

// In Express routes
app.post('/auth/register', authController.register);
app.post('/auth/login', authController.login);
```

### 3.2 Middleware Template

**Location:** `templates/auth/middleware/auth.middleware.ts.hbs`

**Purpose:** Generates authentication and authorization middleware for protecting routes and enforcing role-based access control.

**Available Context:**

The middleware template uses features configuration to determine which security checks to include, RBAC configuration for role hierarchy and permissions, and JWT settings for token verification parameters.

**Generated Output:**

The middleware generates a class with several key methods. The `authenticate` method verifies JWT tokens and attaches user data to the request object. The `optionalAuth` method provides optional authentication without requiring a token. The `requireRole` method checks if the authenticated user has the required role. The `requireEmailVerified` method ensures the user's email is verified (conditional). The `checkAccountLockout` method prevents locked accounts from accessing resources (conditional).

**Key Features:**

JWT verification uses the configured algorithm and validates token expiration, issuer, and audience. Role-based access control implements role hierarchy where higher roles inherit lower role permissions. Account security checks include email verification status and account lockout status. Error handling provides clear error messages for authentication failures.

**Customization Points:**

You can modify token extraction to support different token locations (header, cookie, query), customize user data attachment to include additional fields, add custom authorization logic beyond role checking, implement caching for improved performance, and integrate with external auth providers.

**Example Usage:**

```typescript
// Generated middleware
import { AuthMiddleware } from './middleware/auth.middleware';

const authMiddleware = new AuthMiddleware();

// Protect routes
app.get('/api/profile', 
  authMiddleware.authenticate(),
  (req, res) => { ... }
);

// Role-based protection
app.delete('/api/users/:id',
  authMiddleware.authenticate(),
  authMiddleware.requireRole('admin'),
  (req, res) => { ... }
);
```

### 3.3 Types Template

**Location:** `templates/auth/types/auth.types.ts.hbs`

**Purpose:** Generates TypeScript type definitions for authentication including user types, JWT payloads, token pairs, and error classes.

**Available Context:**

The types template uses RBAC configuration to generate role enums and hierarchy, features configuration to determine which fields to include, security settings for default values, JWT settings for token type definitions, and user model fields for the User interface.

**Generated Output:**

The template generates several key type definitions. The `UserRole` enum lists all available roles. The `ROLE_HIERARCHY` object defines role precedence for permission checking. The `User` interface defines the complete user entity structure. The `PublicUser` type excludes sensitive fields like passwords and tokens. The `JWTPayload` interface defines JWT token structure. The `TokenPair` interface represents access and refresh token pairs. The `AuthConfig` object provides default configuration values. The `AuthError` class and `AUTH_ERRORS` object define authentication errors.

**Key Types:**

```typescript
// Role enum
export enum UserRole {
  USER = 'user',
  ADMIN = 'admin'
}

// User interface
export interface User {
  id: string;
  email: string;
  password: string;
  role: UserRole;
  // ... other fields
}

// JWT payload
export interface JWTPayload {
  userId: string;
  email: string;
  role: UserRole;
  type: 'access' | 'refresh';
}
```

**Customization Points:**

You can add custom user fields to the User interface, define additional role types and hierarchies, create custom error types for specific scenarios, add validation types for request/response schemas, and define custom JWT payload fields.

### 3.4 Routes Template

**Location:** `templates/auth/routes/auth.routes.ts.hbs`

**Purpose:** Generates Express router configuration with all authentication endpoints properly wired to controller methods and middleware.

**Available Context:**

The routes template uses features configuration to determine which routes to include and references to controller and middleware for route setup.

**Generated Output:**

The template generates an Express router with public routes for registration, login, and token refresh, protected routes requiring authentication, conditional routes based on enabled features, and proper middleware application for each route.

**Route Structure:**

Public routes include POST /register for user registration, POST /login for authentication, POST /refresh for token refresh, and POST /logout for session termination. Protected routes include GET /me for current user profile and PUT /me/password for password changes. Conditional routes include GET /verify-email/:token for email verification and POST /forgot-password and POST /reset-password for password recovery.

**Customization Points:**

You can modify route paths to match your API conventions, add rate limiting middleware to specific routes, implement custom validation middleware, add logging or analytics middleware, and organize routes into sub-routers for better structure.

**Example Usage:**

```typescript
// Generated routes
import { authRouter } from './routes/auth.routes';

// Mount in Express app
app.use('/auth', authRouter);

// Routes available:
// POST /auth/register
// POST /auth/login
// POST /auth/refresh
// GET /auth/me
// etc.
```

### 3.5 Service Template

**Location:** `templates/auth/services/auth.service.ts.hbs`

**Purpose:** Generates the authentication service containing business logic for user registration, authentication, token management, and related operations.

**Available Context:**

The service template uses features configuration to determine which methods to implement, security settings for password hashing and validation, RBAC configuration for role assignment, and JWT settings for token generation.

**Generated Output:**

The service generates a class with comprehensive authentication functionality. The `register` method creates new users with password hashing and optional email verification. The `login` method authenticates users and generates tokens with optional account lockout checking. The `refreshToken` method validates refresh tokens and generates new token pairs. The `verifyEmail` method confirms email addresses using verification tokens. The `requestPasswordReset` method generates and sends password reset tokens. The `resetPassword` method validates reset tokens and updates passwords. The `changePassword` method allows authenticated users to change passwords. Helper methods include `hashPassword`, `comparePassword`, `generateTokens`, and `generateSecurityToken`.

**Key Methods:**

```typescript
export class AuthService {
  async register(input: RegisterInput): Promise<TokenPair> {
    // Hash password
    // Create user
    // Generate tokens
    // Send verification email (optional)
  }

  async login(input: LoginInput): Promise<TokenPair> {
    // Find user
    // Check account lockout (optional)
    // Verify password
    // Generate tokens
    // Reset failed attempts
  }

  async refreshToken(refreshToken: string): Promise<TokenPair> {
    // Verify refresh token
    // Generate new tokens
  }
}
```

**Customization Points:**

You can integrate with external user storage (database, LDAP), implement custom password hashing strategies, add multi-factor authentication support, integrate email service for verification and reset, implement token blacklist for logout, and add audit logging for security events.

---

## 4. Handlebars Helpers

Handlebars helpers extend template functionality with custom logic and transformations. Auth Generator includes over 30 built-in helpers organized into categories.

### 4.1 String Helpers

String helpers transform text for proper formatting in generated code.

**uppercase** converts strings to uppercase, useful for constants and enum values.

```handlebars
{{uppercase "user"}}  {{! => USER }}
export const {{uppercase role}}_PERMISSIONS = [...];
```

**lowercase** converts strings to lowercase.

```handlebars
{{lowercase "ADMIN"}}  {{! => admin }}
```

**capitalize** capitalizes the first letter, useful for class names and titles.

```handlebars
{{capitalize "user"}}  {{! => User }}
export class {{capitalize type}}Controller { }
```

**camelCase** converts strings to camelCase, ideal for variable and method names.

```handlebars
{{camelCase "user_role"}}  {{! => userRole }}
const {{camelCase fieldName}} = ...;
```

**pascalCase** converts strings to PascalCase, used for class and interface names.

```handlebars
{{pascalCase "auth_service"}}  {{! => AuthService }}
export class {{pascalCase name}} { }
```

**snakeCase** converts strings to snake_case.

```handlebars
{{snakeCase "userId"}}  {{! => user_id }}
```

**kebabCase** converts strings to kebab-case, useful for file names and URLs.

```handlebars
{{kebabCase "AuthController"}}  {{! => auth-controller }}
```

### 4.2 Array Helpers

Array helpers work with collections in templates.

**includes** checks if an array contains a value.

```handlebars
{{#if (includes roles "admin")}}
  // Admin-specific code
{{/if}}
```

**length** returns the number of elements in an array.

```handlebars
{{#if (gt (length roles) 1)}}
  // Multiple roles
{{/if}}
```

**join** combines array elements with a separator.

```handlebars
{{join permissions ", "}}  {{! => read, write, delete }}
```

**first** gets the first element of an array.

```handlebars
{{first roles}}  {{! => first role }}
```

**last** gets the last element of an array.

```handlebars
{{last roles}}  {{! => last role }}
```

### 4.3 Comparison Helpers

Comparison helpers enable conditional logic in templates.

**eq** checks equality.

```handlebars
{{#if (eq role "admin")}}
  // Admin code
{{/if}}
```

**neq** checks inequality.

```handlebars
{{#if (neq status "active")}}
  // Non-active code
{{/if}}
```

**gt** checks if first value is greater than second.

```handlebars
{{#if (gt minLength 8)}}
  // Strong password requirement
{{/if}}
```

**lt** checks if first value is less than second.

```handlebars
{{#if (lt maxAttempts 5)}}
  // Strict lockout policy
{{/if}}
```

**gte** and **lte** check greater-than-or-equal and less-than-or-equal.

```handlebars
{{#if (gte (length roles) 2)}}
  // Multiple roles
{{/if}}
```

### 4.4 Logical Helpers

Logical helpers combine multiple conditions.

**and** returns true if all arguments are truthy.

```handlebars
{{#if (and features.emailVerification features.passwordReset)}}
  // Both features enabled
{{/if}}
```

**or** returns true if any argument is truthy.

```handlebars
{{#if (or features.emailVerification features.passwordReset)}}
  // At least one feature enabled
{{/if}}
```

**not** negates a value.

```handlebars
{{#if (not features.emailVerification)}}
  // Email verification disabled
{{/if}}
```

### 4.5 Utility Helpers

Utility helpers provide miscellaneous functionality.

**json** stringifies objects to JSON, useful for debugging or configuration.

```handlebars
{{json context}}  {{! => {"key": "value"} }}
```

**add**, **subtract**, **multiply**, **divide** perform arithmetic operations.

```handlebars
{{add 5 3}}  {{! => 8 }}
{{multiply maxAttempts 2}}  {{! => doubled value }}
```

**timestamp** returns the current ISO timestamp.

```handlebars
// Generated at {{timestamp}}
```

**default** provides a fallback value.

```handlebars
{{default optionalField "defaultValue"}}
```

**repeat** repeats a string multiple times.

```handlebars
{{repeat "=" 40}}  {{! => ======================================== }}
```

**truncate** limits string length.

```handlebars
{{truncate description 50}}  {{! => First 50 chars... }}
```

**replace** replaces text in strings.

```handlebars
{{replace path "/" "."}}  {{! => Convert path to dot notation }}
```

---

## 5. Template Context Reference

### 5.1 Features Object

The features object indicates which optional features are enabled in the specification.

```typescript
{
  emailVerification: boolean,    // Email verification enabled
  passwordReset: boolean,        // Password reset enabled
  accountLockout: boolean        // Account lockout enabled
}
```

**Usage in Templates:**

```handlebars
{{#if features.emailVerification}}
  async verifyEmail(token: string): Promise<void> {
    // Email verification logic
  }
{{/if}}

{{#if features.passwordReset}}
  async requestPasswordReset(email: string): Promise<void> {
    // Password reset logic
  }
{{/if}}
```

### 5.2 RBAC Object

The RBAC object contains role-based access control configuration.

```typescript
{
  enabled: boolean,              // RBAC enabled
  roles: Array<{                // Available roles
    name: string,
    permissions?: string[]
  }>,
  defaultRole: string           // Default role for new users
}
```

**Usage in Templates:**

```handlebars
{{#if rbac.enabled}}
  export enum UserRole {
    {{#each rbac.roles}}
    {{uppercase this.name}} = '{{this.name}}',
    {{/each}}
  }

  export const ROLE_HIERARCHY: Record<UserRole, number> = {
    {{#each rbac.roles}}
    [UserRole.{{uppercase this.name}}]: {{@index}},
    {{/each}}
  };
{{/if}}
```

### 5.3 JWT Settings Object

The JWT settings object defines token configuration.

```typescript
{
  algorithm: string,             // e.g., "RS256"
  accessTokenExpiry: string,     // e.g., "15m"
  refreshTokenExpiry: string,    // e.g., "7d"
  issuer: string,               // Token issuer
  audience: string              // Token audience
}
```

**Usage in Templates:**

```handlebars
export const AUTH_CONFIG = {
  jwt: {
    algorithm: '{{jwtSettings.algorithm}}',
    accessTokenExpiry: '{{jwtSettings.accessTokenExpiry}}',
    refreshTokenExpiry: '{{jwtSettings.refreshTokenExpiry}}',
    issuer: '{{jwtSettings.issuer}}',
    audience: '{{jwtSettings.audience}}'
  }
};
```

### 5.4 Security Settings Object

The security settings object defines password and account security requirements.

```typescript
{
  passwordRequirements: {
    minLength: number,           // Minimum password length
    requireUppercase: boolean,   // Require uppercase letters
    requireLowercase: boolean,   // Require lowercase letters
    requireNumbers: boolean,     // Require numbers
    requireSpecialChars: boolean,// Require special characters
    saltRounds: number           // bcrypt salt rounds
  },
  accountLockout: {
    maxAttempts: number,         // Max failed login attempts
    lockoutDuration: number      // Lockout duration in minutes
  }
}
```

**Usage in Templates:**

```handlebars
const passwordSchema = z.string()
  .min({{securitySettings.passwordRequirements.minLength}}, 'Password too short')
  {{#if securitySettings.passwordRequirements.requireUppercase}}
  .regex(/[A-Z]/, 'Must contain uppercase letter')
  {{/if}}
  {{#if securitySettings.passwordRequirements.requireNumbers}}
  .regex(/[0-9]/, 'Must contain number')
  {{/if}};
```

### 5.5 User Model Object

The user model object describes custom user fields beyond the standard authentication fields.

```typescript
{
  fields: Array<{
    name: string,               // Field name
    type: string,               // TypeScript type
    optional?: boolean,         // Is optional
    unique?: boolean,          // Is unique
    default?: any              // Default value
  }>
}
```

**Usage in Templates:**

```handlebars
export interface User {
  id: string;
  email: string;
  password: string;
  role: UserRole;
  {{#each userModel.fields}}
  {{this.name}}: {{this.type}}{{#if this.optional}}?{{/if}};
  {{/each}}
  createdAt: Date;
  updatedAt: Date;
}
```

### 5.6 Excluded Fields Array

An array of field names that should be excluded from certain operations or types.

```typescript
['email', 'password', 'role', 'emailVerified', 'failedLoginAttempts', 'lockedUntil']
```

**Usage in Templates:**

```handlebars
export type PublicUser = Omit<User, {{#each excludedFields}}'{{this}}'{{#unless @last}} | {{/unless}}{{/each}}>;
```

---

## 6. Creating Custom Templates

### 6.1 Template Creation Process

Creating custom templates follows a structured process to ensure compatibility and maintainability.

**Step 1: Create Template File**

Create a new `.hbs` file in the appropriate directory within your custom templates folder. Follow the naming convention of built-in templates.

```bash
custom-templates/
  auth/
    controllers/
      auth.controller.ts.hbs
```

**Step 2: Define Context Requirements**

Document what context data your template needs at the top of the file.

```handlebars
{{!--
  Auth Controller Template
  
  Required Context:
  - features: { emailVerification, passwordReset, accountLockout }
  - securitySettings: { passwordRequirements, accountLockout }
  - rbac: { enabled, roles, defaultRole }
  - userModel: { fields }
--}}
```

**Step 3: Write Template Code**

Implement your template using Handlebars syntax and helpers.

```handlebars
/**
 * Auth Controller
 * Generated by SmartSpec Auth Generator
 */

import { Request, Response, NextFunction } from 'express';
import { AuthService } from '../services/auth.service';

export class AuthController {
  private authService: AuthService;

  constructor() {
    this.authService = new AuthService();
  }

  {{#if features.emailVerification}}
  async verifyEmail(req: Request, res: Response, next: NextFunction): Promise<void> {
    // Implementation
  }
  {{/if}}
}
```

**Step 4: Test Template**

Generate code using your custom template and verify the output.

```typescript
const generator = new AuthGenerator({
  templateDir: './custom-templates'
});

const files = await generator.generateFromFile(specPath, {
  outputDir: './test-output'
});

// Verify generated code
console.log(files[0].content);
```

**Step 5: Register Template**

If adding a new template type (not replacing existing ones), update the generator to load and render your template.

### 6.2 Template Best Practices

**Keep Templates Simple**

Avoid complex logic in templates. Use helpers for calculations and transformations. Keep conditional nesting to a maximum of 2-3 levels. Extract repeated patterns into partials or helpers.

```handlebars
{{! Good - Simple and clear }}
{{#if features.emailVerification}}
  // Email verification code
{{/if}}

{{! Avoid - Too complex }}
{{#if (and features.emailVerification (or (eq role "admin") (eq role "user")))}}
  // Complex nested logic
{{/if}}
```

**Use Helpers for Complex Logic**

Create custom helpers for complex transformations instead of implementing logic in templates.

```typescript
// Helper
Handlebars.registerHelper('isHighRole', (role: string) => {
  return ['admin', 'superadmin'].includes(role);
});

// Template
{{#if (isHighRole role)}}
  // High-privilege code
{{/if}}
```

**Provide Sensible Defaults**

Use the `default` helper to provide fallback values for optional context data.

```handlebars
const maxAttempts = {{default securitySettings.accountLockout.maxAttempts 5}};
```

**Add Comments**

Document complex sections and explain non-obvious logic.

```handlebars
{{! Generate role-specific methods for each role in RBAC }}
{{#each rbac.roles}}
  {{! Role: {{this.name}} }}
  async {{camelCase this.name}}Action(): Promise<void> {
    // Implementation
  }
{{/each}}
```

**Test Edge Cases**

Test your templates with various specifications including minimal features, all features enabled, no RBAC, complex RBAC with many roles, and custom user fields.

### 6.3 Custom Helper Creation

**When to Create Custom Helpers**

Create custom helpers when you need complex string transformations, conditional logic that's used in multiple places, calculations or data processing, or integration with external tools or APIs.

**Helper Function Signature**

Handlebars helpers are JavaScript functions registered with Handlebars.

```typescript
// Simple helper
Handlebars.registerHelper('helperName', (arg1: string, arg2: number) => {
  return `${arg1}-${arg2}`;
});

// Block helper
Handlebars.registerHelper('blockHelper', function(this: any, options: any) {
  if (someCondition) {
    return options.fn(this);  // Render block
  } else {
    return options.inverse(this);  // Render else block
  }
});
```

**Registration Process**

Register helpers in `src/generator/handlebars-helpers.ts` or in your custom generator setup.

```typescript
import Handlebars from 'handlebars';

export function registerCustomHelpers() {
  Handlebars.registerHelper('myHelper', (value: string) => {
    return value.toUpperCase();
  });
}
```

**Testing Helpers**

Write unit tests for custom helpers to ensure they work correctly.

```typescript
import { registerCustomHelpers } from './handlebars-helpers';
import Handlebars from 'handlebars';

describe('Custom Helpers', () => {
  beforeAll(() => {
    registerCustomHelpers();
  });

  it('should transform value correctly', () => {
    const template = Handlebars.compile('{{myHelper value}}');
    const result = template({ value: 'test' });
    expect(result).toBe('TEST');
  });
});
```

---

## 7. Template Examples

### 7.1 Conditional Rendering

Conditional rendering allows templates to generate different code based on specification features.

**Single Condition:**

```handlebars
{{#if features.emailVerification}}
  async verifyEmail(token: string): Promise<User> {
    const user = await this.findByVerificationToken(token);
    user.emailVerified = true;
    user.emailVerificationToken = undefined;
    await this.saveUser(user);
    return user;
  }
{{/if}}
```

**If-Else:**

```handlebars
{{#if rbac.enabled}}
  role: UserRole.{{uppercase rbac.defaultRole}},
{{else}}
  role: 'user',
{{/if}}
```

**Multiple Conditions:**

```handlebars
{{#if features.emailVerification}}
  emailVerified: false,
  emailVerificationToken: this.generateToken(),
{{/if}}

{{#if features.passwordReset}}
  resetPasswordToken: undefined,
  resetPasswordExpires: undefined,
{{/if}}

{{#if features.accountLockout}}
  failedLoginAttempts: 0,
  lockedUntil: undefined,
{{/if}}
```

### 7.2 Iterating Arrays

Iteration allows templates to generate code for each item in a collection.

**Basic Iteration:**

```handlebars
{{#each rbac.roles}}
  {{uppercase this.name}} = '{{this.name}}',
{{/each}}
```

**With Index:**

```handlebars
{{#each rbac.roles}}
  [UserRole.{{uppercase this.name}}]: {{@index}},
{{/each}}
```

**With Conditional:**

```handlebars
{{#each userModel.fields}}
  {{#unless (includes excludedFields this.name)}}
  {{this.name}}: {{this.type}}{{#if this.optional}}?{{/if}};
  {{/unless}}
{{/each}}
```

**Nested Iteration:**

```handlebars
{{#each endpoints}}
  // {{this.path}}
  {{#each this.methods}}
    {{uppercase this}}: {
      auth: {{../requiresAuth}},
      {{#if ../roles}}
      roles: [{{#each ../roles}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}]
      {{/if}}
    },
  {{/each}}
{{/each}}
```

### 7.3 Using Helpers

Helpers enhance templates with powerful transformations and logic.

**String Transformation:**

```handlebars
export class {{pascalCase componentName}}Controller {
  private {{camelCase serviceName}}: {{pascalCase serviceName}};

  async {{camelCase actionName}}(req: Request, res: Response): Promise<void> {
    // Implementation
  }
}
```

**Comparison:**

```handlebars
{{#if (gt securitySettings.passwordRequirements.minLength 8)}}
  // Strong password policy
  .min({{securitySettings.passwordRequirements.minLength}}, 'Password must be very strong')
{{else}}
  // Standard password policy
  .min(8, 'Password must be at least 8 characters')
{{/if}}
```

**Logical Operations:**

```handlebars
{{#if (and features.emailVerification (not features.passwordReset))}}
  // Email verification only
{{/if}}

{{#if (or features.emailVerification features.passwordReset)}}
  // Either feature enabled
{{/if}}
```

**Array Operations:**

```handlebars
{{#if (includes rbac.roles "admin")}}
  // Admin role exists
{{/if}}

{{#if (gt (length rbac.roles) 2)}}
  // Multiple roles defined
  const roles = [{{join (map rbac.roles "name") ", "}}];
{{/if}}
```

### 7.4 Complex Examples

**Dynamic Method Generation:**

```handlebars
export class AuthMiddleware {
  {{#each rbac.roles}}
  /**
   * Require {{capitalize this.name}} role or higher
   */
  require{{pascalCase this.name}}(): RequestHandler {
    return this.requireRole(UserRole.{{uppercase this.name}});
  }
  {{/each}}

  /**
   * Check if user has required role
   */
  private requireRole(requiredRole: UserRole): RequestHandler {
    return (req: Request, res: Response, next: NextFunction) => {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      if (!hasRole(req.user.role, requiredRole)) {
        return res.status(403).json({ error: 'Insufficient permissions' });
      }

      next();
    };
  }
}
```

**Conditional Imports:**

```handlebars
import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';
{{#if features.emailVerification}}
import { sendVerificationEmail } from '../utils/email';
{{/if}}
{{#if features.passwordReset}}
import { sendPasswordResetEmail } from '../utils/email';
{{/if}}
{{#if rbac.enabled}}
import { UserRole, hasRole } from '../types/auth.types';
{{/if}}
```

**Configuration Object:**

```handlebars
export const AUTH_CONFIG = {
  jwt: {
    algorithm: '{{jwtSettings.algorithm}}',
    accessTokenExpiry: '{{jwtSettings.accessTokenExpiry}}',
    refreshTokenExpiry: '{{jwtSettings.refreshTokenExpiry}}',
    {{#if jwtSettings.issuer}}
    issuer: '{{jwtSettings.issuer}}',
    {{/if}}
    {{#if jwtSettings.audience}}
    audience: '{{jwtSettings.audience}}',
    {{/if}}
  },
  security: {
    passwordRequirements: {
      minLength: {{securitySettings.passwordRequirements.minLength}},
      requireUppercase: {{securitySettings.passwordRequirements.requireUppercase}},
      requireLowercase: {{securitySettings.passwordRequirements.requireLowercase}},
      requireNumbers: {{securitySettings.passwordRequirements.requireNumbers}},
      requireSpecialChars: {{securitySettings.passwordRequirements.requireSpecialChars}},
      saltRounds: {{securitySettings.passwordRequirements.saltRounds}},
    },
    {{#if features.accountLockout}}
    accountLockout: {
      maxAttempts: {{securitySettings.accountLockout.maxAttempts}},
      lockoutDuration: {{securitySettings.accountLockout.lockoutDuration}},
    },
    {{/if}}
  },
  {{#if rbac.enabled}}
  rbac: {
    defaultRole: UserRole.{{uppercase rbac.defaultRole}},
    roles: [
      {{#each rbac.roles}}
      UserRole.{{uppercase this.name}},
      {{/each}}
    ],
  },
  {{/if}}
};
```

---

## 8. Framework Integration

### 8.1 Express.js Integration

Express.js is the most common framework for Node.js web applications. The default templates are designed for Express.js compatibility.

**Basic Setup:**

```typescript
// Generate auth code
import { AuthGenerator } from '@smartspec/auth-generator';

const generator = new AuthGenerator();
await generator.generateFromFile('./specs/auth-spec.md', {
  outputDir: './src/auth'
});

// app.ts
import express from 'express';
import { authRouter } from './auth/routes/auth.routes';

const app = express();

app.use(express.json());
app.use('/auth', authRouter);

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

**Protected Routes:**

```typescript
import { AuthMiddleware } from './auth/middleware/auth.middleware';

const authMiddleware = new AuthMiddleware();

// Require authentication
app.get('/api/profile',
  authMiddleware.authenticate(),
  (req, res) => {
    res.json({ user: req.user });
  }
);

// Require specific role
app.delete('/api/users/:id',
  authMiddleware.authenticate(),
  authMiddleware.requireRole('admin'),
  (req, res) => {
    // Admin only
  }
);

// Optional authentication
app.get('/api/posts',
  authMiddleware.optionalAuth(),
  (req, res) => {
    // req.user available if authenticated
  }
);
```

**Error Handling:**

```typescript
import { AuthError } from './auth/types/auth.types';

// Error handling middleware
app.use((error: Error, req: Request, res: Response, next: NextFunction) => {
  if (error instanceof AuthError) {
    return res.status(error.statusCode).json({
      error: error.message,
      code: error.code
    });
  }

  console.error('Unhandled error:', error);
  res.status(500).json({ error: 'Internal server error' });
});
```

**Database Integration:**

```typescript
// Extend generated service with database operations
import { AuthService } from './auth/services/auth.service';
import { PrismaClient } from '@prisma/client';

export class AuthServiceWithDB extends AuthService {
  private prisma: PrismaClient;

  constructor() {
    super();
    this.prisma = new PrismaClient();
  }

  async findUserByEmail(email: string) {
    return this.prisma.user.findUnique({ where: { email } });
  }

  async createUser(data: any) {
    return this.prisma.user.create({ data });
  }

  async updateUser(id: string, data: any) {
    return this.prisma.user.update({ where: { id }, data });
  }
}
```

**Complete Express Example:**

```typescript
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import { authRouter } from './auth/routes/auth.routes';
import { AuthMiddleware } from './auth/middleware/auth.middleware';

const app = express();
const authMiddleware = new AuthMiddleware();

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(','),
  credentials: true
}));

// Rate limiting
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // 10 requests per window
  message: 'Too many authentication attempts'
});

// Body parsing
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Auth routes with rate limiting
app.use('/auth', authLimiter, authRouter);

// Protected API routes
app.use('/api',
  authMiddleware.authenticate(),
  apiRouter
);

// Admin routes
app.use('/admin',
  authMiddleware.authenticate(),
  authMiddleware.requireRole('admin'),
  adminRouter
);

// Error handling
app.use((error: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(error);
  res.status(500).json({ error: 'Internal server error' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### 8.2 NestJS Integration

NestJS is a progressive Node.js framework that uses TypeScript and follows Angular-like patterns. While the default templates are Express-focused, they can be adapted for NestJS.

**Custom NestJS Templates:**

Create NestJS-compatible templates with decorators and dependency injection.

```handlebars
{{! auth.controller.ts.hbs for NestJS }}
import { Controller, Post, Get, Body, Req, UseGuards } from '@nestjs/common';
import { AuthService } from './auth.service';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { RolesGuard } from './guards/roles.guard';
import { Roles } from './decorators/roles.decorator';
{{#if rbac.enabled}}
import { UserRole } from './types/auth.types';
{{/if}}

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Get('me')
  @UseGuards(JwtAuthGuard)
  async getProfile(@Req() req) {
    return req.user;
  }

  {{#if rbac.enabled}}
  @Get('admin/users')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(UserRole.ADMIN)
  async getUsers() {
    return this.authService.getAllUsers();
  }
  {{/if}}
}
```

**NestJS Module Setup:**

```typescript
// Generate with NestJS templates
const generator = new AuthGenerator({
  templateDir: './templates/nestjs'
});

await generator.generateFromFile('./specs/auth-spec.md', {
  outputDir: './src/auth'
});

// auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { JwtStrategy } from './strategies/jwt.strategy';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { RolesGuard } from './guards/roles.guard';

@Module({
  imports: [
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '15m' },
    }),
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    JwtStrategy,
    JwtAuthGuard,
    RolesGuard,
  ],
  exports: [AuthService, JwtAuthGuard, RolesGuard],
})
export class AuthModule {}
```

**NestJS Guards:**

```typescript
// jwt-auth.guard.ts
import { Injectable, ExecutionContext } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    return super.canActivate(context);
  }
}

// roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserRole } from '../types/auth.types';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.get<UserRole[]>(
      'roles',
      context.getHandler()
    );

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.role === role);
  }
}
```

**NestJS Decorators:**

```typescript
// roles.decorator.ts
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '../types/auth.types';

export const Roles = (...roles: UserRole[]) => SetMetadata('roles', roles);

// current-user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);
```

**Usage in NestJS Controllers:**

```typescript
import { Controller, Get, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { RolesGuard } from './guards/roles.guard';
import { Roles } from './decorators/roles.decorator';
import { CurrentUser } from './decorators/current-user.decorator';
import { UserRole, User } from './types/auth.types';

@Controller('api')
@UseGuards(JwtAuthGuard)
export class ApiController {
  @Get('profile')
  getProfile(@CurrentUser() user: User) {
    return user;
  }

  @Get('admin/dashboard')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  getAdminDashboard(@CurrentUser() user: User) {
    return { message: 'Admin dashboard', user };
  }
}
```

### 8.3 Other Frameworks

The template system can be adapted for other frameworks by creating custom templates.

**Fastify:**

```handlebars
{{! Fastify controller template }}
import { FastifyRequest, FastifyReply } from 'fastify';
import { AuthService } from '../services/auth.service';

export class AuthController {
  private authService: AuthService;

  constructor() {
    this.authService = new AuthService();
  }

  async register(request: FastifyRequest, reply: FastifyReply) {
    try {
      const result = await this.authService.register(request.body);
      reply.code(201).send(result);
    } catch (error) {
      reply.code(400).send({ error: error.message });
    }
  }
}
```

**Koa:**

```handlebars
{{! Koa controller template }}
import { Context } from 'koa';
import { AuthService } from '../services/auth.service';

export class AuthController {
  private authService: AuthService;

  constructor() {
    this.authService = new AuthService();
  }

  async register(ctx: Context) {
    try {
      const result = await this.authService.register(ctx.request.body);
      ctx.status = 201;
      ctx.body = result;
    } catch (error) {
      ctx.status = 400;
      ctx.body = { error: error.message };
    }
  }
}
```

---

## 9. Template Debugging

### 9.1 Common Issues

**Undefined Variables:**

When a template tries to access a variable that doesn't exist in the context, Handlebars renders an empty string.

```handlebars
{{! If 'missingVar' doesn't exist, this renders nothing }}
{{missingVar}}

{{! Use default helper to provide fallback }}
{{default missingVar "fallback value"}}
```

**Helper Not Found:**

If you use a helper that hasn't been registered, Handlebars throws an error.

```
Error: Missing helper: "myCustomHelper"
```

Solution: Ensure the helper is registered before template compilation.

```typescript
Handlebars.registerHelper('myCustomHelper', (value) => {
  return value.toUpperCase();
});
```

**Syntax Errors:**

Mismatched opening and closing tags cause parsing errors.

```handlebars
{{! Error: Missing closing tag }}
{{#if condition}}
  Content
{{! Missing {{/if}} }}

{{! Error: Wrong closing tag }}
{{#if condition}}
  Content
{{/unless}}  {{! Should be {{/if}} }}
```

**Context Mismatch:**

Accessing properties that don't exist in the context structure.

```handlebars
{{! If 'features' doesn't have 'nonexistentFeature' }}
{{#if features.nonexistentFeature}}
  {{! This block never renders }}
{{/if}}
```

### 9.2 Debug Techniques

**Inspect Context:**

Use the `json` helper to view the entire context or specific objects.

```handlebars
{{! View entire context }}
<!-- DEBUG: {{json this}} -->

{{! View specific object }}
<!-- Features: {{json features}} -->
<!-- RBAC: {{json rbac}} -->
```

**Add Debug Comments:**

Add comments to track template execution flow.

```handlebars
{{! === START: Email Verification Section === }}
{{#if features.emailVerification}}
  {{! Email verification is enabled }}
  async verifyEmail(token: string) {
    // Implementation
  }
{{else}}
  {{! Email verification is disabled }}
{{/if}}
{{! === END: Email Verification Section === }}
```

**Test with Minimal Context:**

Create a minimal test context to isolate issues.

```typescript
const minimalContext = {
  features: {
    emailVerification: true,
    passwordReset: false,
    accountLockout: false
  }
};

const template = Handlebars.compile(templateSource);
const output = template(minimalContext);
console.log(output);
```

**Check Helper Registration:**

Verify that all helpers used in templates are registered.

```typescript
// List registered helpers
console.log('Registered helpers:', Object.keys(Handlebars.helpers));

// Test helper directly
const helper = Handlebars.helpers['myHelper'];
if (helper) {
  console.log('Helper output:', helper('test'));
}
```

### 9.3 Validation

**Syntax Validation:**

Compile templates to catch syntax errors early.

```typescript
try {
  const template = Handlebars.compile(templateSource);
  console.log('✓ Template syntax valid');
} catch (error) {
  console.error('✗ Template syntax error:', error.message);
}
```

**Context Validation:**

Verify that the context contains all required data.

```typescript
function validateContext(context: any): string[] {
  const errors: string[] = [];

  if (!context.features) {
    errors.push('Missing required field: features');
  }

  if (context.rbac?.enabled && !context.rbac.roles) {
    errors.push('RBAC enabled but no roles defined');
  }

  return errors;
}

const errors = validateContext(context);
if (errors.length > 0) {
  console.error('Context validation failed:', errors);
}
```

**Output Validation:**

Check that generated code is valid TypeScript.

```typescript
import * as ts from 'typescript';

function validateTypeScript(code: string): boolean {
  const result = ts.transpileModule(code, {
    compilerOptions: {
      target: ts.ScriptTarget.ES2020,
      module: ts.ModuleKind.CommonJS
    }
  });

  return result.diagnostics?.length === 0;
}

const isValid = validateTypeScript(generatedCode);
if (!isValid) {
  console.error('Generated code has TypeScript errors');
}
```

---

## 10. Template Variants

### 10.1 Basic Variant

The basic variant generates minimal authentication functionality suitable for simple applications.

**Features:**
- Email/password authentication
- JWT tokens
- Basic user model
- No email verification
- No password reset
- No RBAC
- Standard security settings

**Use Cases:**
- Internal tools
- Prototypes
- Simple applications
- Learning projects

**Example Spec:**

```markdown
# Authentication Specification: Basic App

## User Model
- id: string (UUID)
- email: string (unique)
- password: string (hashed)

## Features
- Email verification: no
- Password reset: no

## Token Configuration
- Access Token: 15 minutes
- Refresh Token: 7 days
```

### 10.2 Standard Variant

The standard variant includes commonly needed features for typical web applications.

**Features:**
- Email/password authentication
- JWT tokens
- Email verification
- Password reset
- Basic RBAC (2-3 roles)
- Account lockout
- Standard security settings

**Use Cases:**
- SaaS applications
- E-commerce sites
- Content management systems
- Most web applications (80% use cases)

**Example Spec:**

```markdown
# Authentication Specification: Standard App

## User Model
- id: string (UUID)
- email: string (unique)
- password: string (hashed)
- role: enum (user, admin)

## Features
- Email verification: yes
- Password reset: yes
- RBAC: enabled
  - Roles: user, admin
  - Default: user

## Security Settings
- Password: min 8 characters
- Max login attempts: 5
- Lockout duration: 15 minutes
```

### 10.3 Advanced Variant

The advanced variant provides comprehensive authentication for complex applications.

**Features:**
- Email/password authentication
- JWT tokens with extended configuration
- Email verification
- Password reset
- Advanced RBAC (4+ roles)
- Account lockout
- Enhanced security settings
- Custom user fields

**Use Cases:**
- Enterprise applications
- Multi-tenant systems
- Applications with complex permissions
- High-security requirements

**Example Spec:**

```markdown
# Authentication Specification: Advanced App

## User Model
- id: string (UUID)
- email: string (unique)
- password: string (hashed)
- firstName: string
- lastName: string
- role: enum (user, manager, admin, superadmin)
- department: string

## Features
- Email verification: yes
- Password reset: yes
- RBAC: enabled
  - Roles: user, manager, admin, superadmin
  - Default: user

## Security Settings
- Password: min 12 characters, require uppercase, lowercase, number, special
- Max login attempts: 3
- Lockout duration: 60 minutes

## Token Configuration
- Access Token: 30 minutes
- Refresh Token: 30 days
- Algorithm: RS256
```

### 10.4 Enterprise Variant

The enterprise variant includes all features plus integration points for enterprise systems.

**Features:**
- All advanced features
- SSO integration hooks
- Multi-factor authentication support
- Advanced audit logging
- Custom workflows
- API key authentication
- Service account support

**Use Cases:**
- Large enterprise systems
- Regulated industries
- Multi-region deployments
- Complex integration requirements

---

## 11. Advanced Topics

### 11.1 Template Composition

Template composition allows you to build complex templates from smaller, reusable pieces.

**Using Partials:**

```handlebars
{{! _validation-schema.hbs partial }}
const {{schemaName}} = z.object({
  email: z.string().email(),
  password: z.string().min({{minLength}}),
});

{{! Main template }}
{{> _validation-schema schemaName="registerSchema" minLength=8}}
{{> _validation-schema schemaName="loginSchema" minLength=1}}
```

**Template Inheritance:**

While Handlebars doesn't have built-in inheritance, you can simulate it with conditionals and partials.

```handlebars
{{! base-controller.hbs }}
export class {{className}} {
  {{#if includeConstructor}}
  constructor() {
    // Constructor
  }
  {{/if}}

  {{> methods}}
}

{{! auth-controller.hbs }}
{{#with (extend base {className: "AuthController", includeConstructor: true})}}
  {{> base-controller}}
{{/with}}
```

**Shared Components:**

Extract common patterns into reusable helpers or partials.

```typescript
// Helper for common error handling
Handlebars.registerHelper('errorHandler', () => {
  return new Handlebars.SafeString(`
    try {
      // Method implementation
    } catch (error) {
      next(error);
    }
  `);
});
```

### 11.2 Performance Optimization

**Template Caching:**

Templates are automatically cached after first compilation. Reuse generator instances to benefit from caching.

```typescript
// Good - Templates cached
const generator = new AuthGenerator();
for (const spec of specs) {
  await generator.generateFromFile(spec, options);
}

// Bad - Templates recompiled each time
for (const spec of specs) {
  const generator = new AuthGenerator();
  await generator.generateFromFile(spec, options);
}
```

**Context Preparation:**

Prepare context data efficiently to minimize processing time.

```typescript
// Prepare context once
const context = prepareContext(ast);

// Render multiple templates with same context
const controller = controllerTemplate(context);
const middleware = middlewareTemplate(context);
const types = typesTemplate(context);
```

**Lazy Loading:**

Load templates only when needed for specific features.

```typescript
if (ast.features.emailVerification) {
  const emailTemplate = await loadTemplate('email-verification');
  const emailCode = emailTemplate(context);
}
```

### 11.3 Internationalization

Generate code with internationalized strings and multi-language support.

**i18n Helper:**

```typescript
Handlebars.registerHelper('t', (key: string, locale: string = 'en') => {
  const translations = {
    en: {
      'error.invalid_credentials': 'Invalid credentials',
      'error.user_exists': 'User already exists'
    },
    th: {
      'error.invalid_credentials': 'ข้อมูลไม่ถูกต้อง',
      'error.user_exists': 'ผู้ใช้มีอยู่แล้ว'
    }
  };

  return translations[locale]?.[key] || key;
});
```

**Multi-language Templates:**

```handlebars
export const AUTH_ERRORS = {
  INVALID_CREDENTIALS: new AuthError(
    '{{t "error.invalid_credentials" locale}}',
    'INVALID_CREDENTIALS',
    401
  ),
  USER_EXISTS: new AuthError(
    '{{t "error.user_exists" locale}}',
    'USER_EXISTS',
    409
  ),
};
```

---

## 12. Best Practices

### Template Organization

Organize templates logically by component type and feature. Keep related templates in the same directory. Use consistent naming conventions across all templates. Document template dependencies and requirements.

### Code Quality

Generate clean, readable code with proper indentation and formatting. Include comprehensive comments and documentation. Follow TypeScript best practices in generated code. Ensure generated code passes linting and type checking.

### Security

Never include sensitive data in templates. Use parameterized queries in database operations. Implement proper input validation in generated code. Follow OWASP security guidelines for authentication.

### Maintainability

Keep templates simple and focused on single responsibilities. Use helpers for complex logic instead of template code. Document customization points for future modifications. Version templates alongside the generator.

### Testing

Test templates with various specification configurations. Verify generated code compiles without errors. Test generated code functionality with integration tests. Maintain high test coverage for template rendering.

---

## 13. Appendix

### 13.1 Complete Helper Reference

See [Handlebars Helpers](#4-handlebars-helpers) section for detailed documentation of all 30+ built-in helpers including string manipulation, array operations, comparisons, logical operations, and utilities.

### 13.2 Template Cheat Sheet

**Common Patterns:**

```handlebars
{{! Conditional rendering }}
{{#if condition}}...{{/if}}

{{! Iteration }}
{{#each array}}{{this}}{{/each}}

{{! String transformation }}
{{uppercase text}}
{{capitalize text}}
{{camelCase text}}

{{! Comparison }}
{{#if (eq a b)}}...{{/if}}
{{#if (gt a b)}}...{{/if}}

{{! Logical operations }}
{{#if (and a b)}}...{{/if}}
{{#if (or a b)}}...{{/if}}

{{! Default value }}
{{default value "fallback"}}

{{! JSON output }}
{{json object}}
```

### 13.3 Troubleshooting Guide

**Error: "Missing helper"**
- Solution: Register the helper before compiling templates

**Error: "Cannot read property of undefined"**
- Solution: Check context structure and use default helper

**Generated code has TypeScript errors**
- Solution: Validate context data and test with TypeScript compiler

**Template renders empty output**
- Solution: Check conditionals and context values with json helper

**Performance issues**
- Solution: Reuse generator instances and optimize context preparation

---

**End of Template Usage Guide**

For API documentation, see [API Documentation](./API_DOCUMENTATION.md).

For quick start examples, see [Quick Start Guide](./QUICK_START.md).

For helper reference, see [Helper Reference](./HELPER_REFERENCE.md).
