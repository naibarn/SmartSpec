/**
 * Auth Middleware
 * 
 * JWT verification and authorization middleware
 * Generated by SmartSpec Auth Generator
 */

import { Request, Response, NextFunction } from 'express';
import { JWTService } from '../services/jwt.service';
import { UserRepository } from '../repositories/user.repository.interface';
import { JWTPayload, UserRole } from '../types/auth.types';
import { isJWTPayload, assertUserRoles } from '../utils/type-guards';

// Use Express.Request with extended type from express.d.ts
// req.user will be JWTPayload, not full User object

export class AuthMiddleware {
  private jwtService: JWTService;
  private userRepository?: UserRepository;

  constructor(jwtService: JWTService, userRepository?: UserRepository) {
    this.jwtService = jwtService;
    this.userRepository = userRepository;
  }

  /**
   * Verify JWT token and attach user to request
   */
  authenticate = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      // Get token from header
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        res.status(401).json({
          success: false,
          error: 'No token provided',
        });
        return;
      }

      const token = authHeader.substring(7); // Remove 'Bearer ' prefix

      // Verify token
      const payload = this.jwtService.verifyAccessToken(token);
      
      // Type guard to ensure payload is valid
      if (!isJWTPayload(payload)) {
        res.status(401).json({
          success: false,
          error: 'Invalid token payload',
        });
        return;
      }

      // Get user from database (this would be done by the database layer)
      // For now, we'll assume the user is retrieved and attached
      // In production, you would query the database here:
      // const user = await userRepository.findById(payload.userId);
      
      // Attach JWT payload to request
      req.user = payload;

      next();
    } catch (error) {
      res.status(401).json({
        success: false,
        error: 'Invalid or expired token',
      });
    }
  };

  /**
   * Check if user has required role
   */
  requireRole = (allowedRoles: UserRole[]) => {
    return async (
      req: Request,
      res: Response,
      next: NextFunction
    ): Promise<void> => {
      try {
        const user = req.user;
        if (!user) {
          res.status(401).json({
            success: false,
            error: 'Unauthorized',
          });
          return;
        }

        if (!allowedRoles.includes(user.role)) {
          res.status(403).json({
            success: false,
            error: 'Insufficient permissions',
          });
          return;
        }

        next();
      } catch (error) {
        next(error);
      }
    };
  };

  /**
   * Require user role
   */
  requireUser = this.requireRole([UserRole.USER]);

  /**
   * Require admin role
   */
  requireAdmin = this.requireRole([UserRole.ADMIN]);


  /**
   * Optional authentication - attach user if token is valid, but don't fail if not
   */
  optionalAuth = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        next();
        return;
      }

      const token = authHeader.substring(7);
      const payload = this.jwtService.verifyAccessToken(token);
      
      // Type guard to ensure payload is valid
      if (isJWTPayload(payload)) {
        req.user = payload;
      }

      next();
    } catch (error) {
      // Token invalid, but that's okay for optional auth
      next();
    }
  };

  /**
   * Check if account is locked
   */
  checkAccountLockout = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const jwtPayload = req.user;
      if (!jwtPayload || !this.userRepository) {
        next();
        return;
      }

      // Fetch full user from database
      const user = await this.userRepository.findById(jwtPayload.userId);
      if (!user) {
        res.status(401).json({
          success: false,
          error: 'User not found',
        });
        return;
      }

      // Check if account is locked
      if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {
        const remainingMinutes = Math.ceil(
          (new Date(user.lockedUntil).getTime() - Date.now()) / 60000
        );
        res.status(423).json({
          success: false,
          error: `Account is locked. Try again in ${remainingMinutes} minutes`,
        });
        return;
      }

      next();
    } catch (error) {
      next(error);
    }
  };

  /**
   * Require email verification
   */
  requireEmailVerified = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const jwtPayload = req.user;
      if (!jwtPayload || !this.userRepository) {
        res.status(401).json({
          success: false,
          error: 'Unauthorized',
        });
        return;
      }

      // Fetch full user from database
      const user = await this.userRepository.findById(jwtPayload.userId);
      if (!user) {
        res.status(401).json({
          success: false,
          error: 'User not found',
        });
        return;
      }

      if (!user.emailVerified) {
        res.status(403).json({
          success: false,
          error: 'Email not verified. Please verify your email first',
        });
        return;
      }

      next();
    } catch (error) {
      next(error);
    }
  };
}

/**
 * Helper to create middleware instance
 */
export function createAuthMiddleware(jwtService: JWTService, userRepository?: UserRepository): AuthMiddleware {
  return new AuthMiddleware(jwtService, userRepository);
}
