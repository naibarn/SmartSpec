/**
 * Auth Service
 * 
 * Handles authentication business logic
 * Generated by SmartSpec Auth Generator
 */

import { randomBytes } from 'crypto';
import { JWTService } from './jwt.service';
import { PasswordService } from './password.service';
import { EmailService } from './email.service';
import { UserRepository } from '../repositories/user.repository.interface';
import { User, PublicUser, RegisterInput, LoginInput, TokenPair, UserRole } from '../types/auth.types';

export class AuthService {
  private jwtService: JWTService;
  private passwordService: PasswordService;
  private emailService: EmailService;
  private userRepository: UserRepository;

  constructor(userRepository: UserRepository) {
    this.userRepository = userRepository;
    this.jwtService = new JWTService();
    this.passwordService = new PasswordService();
    this.emailService = new EmailService();
  }

  /**
   * Register new user
   */
  async register(input: RegisterInput): Promise<{ user: PublicUser; tokens: TokenPair }> {
    // 1. Validate password strength
    const passwordValidation = this.passwordService.validate(input.password);
    if (!passwordValidation.valid) {
      throw new Error(`Password validation failed: ${passwordValidation.errors.join(', ')}`);
    }

    // 2. Check if user exists
    const existingUser = await this.userRepository.findByEmail(input.email);
    if (existingUser) {
      throw new Error('User with this email already exists');
    }

    // 3. Hash password
    const hashedPassword = await this.passwordService.hash(input.password);

    // 4. Create user
    const user = await this.userRepository.create({
      email: input.email,
      password: hashedPassword,
      role: 'user',
      name: input.name,
    });

    // 5. Generate email verification token
    const verificationToken = this.generateSecureToken();
    const verificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    await this.userRepository.update(user.id, {
      emailVerificationToken: verificationToken,
      emailVerificationExpires: verificationExpires,
    });

    // 6. Send verification email
    await this.emailService.sendVerificationEmail(user.email, verificationToken);

    // 7. Generate tokens
    const tokens = this.jwtService.generateTokenPair(user.id, user.email, user.role);

    // 8. Remove password from response
    const { password, ...publicUser } = user;

    return {
      user: publicUser as PublicUser,
      tokens,
    };
  }

  /**
   * Login user
   */
  async login(input: LoginInput): Promise<{ user: PublicUser; tokens: TokenPair }> {
    // 1. Find user
    const user = await this.userRepository.findByEmail(input.email);
    if (!user) {
      throw new Error('Invalid credentials');
    }

    // 2. Check if account is locked
    if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {
      const remainingTime = Math.ceil((new Date(user.lockedUntil).getTime() - Date.now()) / 60000);
      throw new Error(`Account is locked. Try again in ${remainingTime} minutes`);
    }

    // 3. Verify password
    const isValid = await this.passwordService.compare(input.password, user.password);
    
    if (!isValid) {
      // Increment failed attempts
      const failedAttempts = (user.failedLoginAttempts || 0) + 1;
      const updates: any = { failedLoginAttempts: failedAttempts };
      
      // Lock account if max attempts reached
      if (failedAttempts >= 5) {
        updates.lockedUntil = new Date(Date.now() + 30 * 60 * 1000);
      }
      
      await this.userRepository.update(user.id, updates);
      
      throw new Error('Invalid credentials');
    }

    // 4. Reset failed attempts on successful login
    if (user.failedLoginAttempts && user.failedLoginAttempts > 0) {
      await this.userRepository.update(user.id, {
        failedLoginAttempts: 0,
        lockedUntil: undefined,
      });
    }

    // 5. Generate tokens
    const tokens = this.jwtService.generateTokenPair(user.id, user.email, user.role);

    // 6. Remove password from response
    const { password, ...publicUser } = user;

    return {
      user: publicUser as PublicUser,
      tokens,
    };
  }

  /**
   * Refresh tokens
   */
  async refreshTokens(refreshToken: string): Promise<TokenPair> {
    // 1. Verify refresh token
    const payload = this.jwtService.verifyRefreshToken(refreshToken);

    // 2. Find user
    const user = await this.userRepository.findById(payload.userId);
    if (!user) {
      throw new Error('User not found');
    }

    // 3. Generate new token pair
    return this.jwtService.generateTokenPair(user.id, user.email, user.role);
  }

  /**
   * Verify email
   */
  async verifyEmail(token: string): Promise<void> {
    // 1. Find user by token
    const user = await this.userRepository.findByEmailVerificationToken(token);
    if (!user) {
      throw new Error('Invalid verification token');
    }

    // 2. Check token expiry
    if (user.emailVerificationExpires && new Date(user.emailVerificationExpires) < new Date()) {
      throw new Error('Verification token has expired');
    }

    // 3. Update user
    await this.userRepository.update(user.id, {
      emailVerified: true,
      emailVerificationToken: undefined,
      emailVerificationExpires: undefined,
    });
  }

  /**
   * Resend verification email
   */
  async resendVerificationEmail(email: string): Promise<void> {
    // 1. Find user
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      throw new Error('User not found');
    }

    // 2. Check if already verified
    if (user.emailVerified) {
      throw new Error('Email is already verified');
    }

    // 3. Generate new token
    const verificationToken = this.generateSecureToken();
    const verificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000);

    await this.userRepository.update(user.id, {
      emailVerificationToken: verificationToken,
      emailVerificationExpires: verificationExpires,
    });

    // 4. Send email
    await this.emailService.sendVerificationEmail(user.email, verificationToken);
  }

  /**
   * Request password reset
   */
  async requestPasswordReset(email: string): Promise<void> {
    // 1. Find user
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      // Don't reveal if user exists
      return;
    }

    // 2. Generate reset token
    const resetToken = this.generateSecureToken();
    const resetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    // 3. Save token
    await this.userRepository.update(user.id, {
      resetPasswordToken: resetToken,
      resetPasswordExpires: resetExpires,
    });

    // 4. Send email
    await this.emailService.sendPasswordResetEmail(user.email, resetToken);
  }

  /**
   * Reset password
   */
  async resetPassword(token: string, newPassword: string): Promise<void> {
    // 1. Find user by token
    const user = await this.userRepository.findByResetPasswordToken(token);
    if (!user) {
      throw new Error('Invalid reset token');
    }

    // 2. Check token expiry
    if (user.resetPasswordExpires && new Date(user.resetPasswordExpires) < new Date()) {
      throw new Error('Reset token has expired');
    }

    // 3. Validate new password
    const validation = this.passwordService.validate(newPassword);
    if (!validation.valid) {
      throw new Error(`Password validation failed: ${validation.errors.join(', ')}`);
    }

    // 4. Hash new password
    const hashedPassword = await this.passwordService.hash(newPassword);

    // 5. Update user
    await this.userRepository.update(user.id, {
      password: hashedPassword,
      resetPasswordToken: undefined,
      resetPasswordExpires: undefined,
    });
  }

  /**
   * Change password (authenticated user)
   */
  async changePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {
    // 1. Find user
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    // 2. Verify current password
    const isValid = await this.passwordService.compare(currentPassword, user.password);
    if (!isValid) {
      throw new Error('Current password is incorrect');
    }

    // 3. Validate new password
    const validation = this.passwordService.validate(newPassword);
    if (!validation.valid) {
      throw new Error(`Password validation failed: ${validation.errors.join(', ')}`);
    }

    // 4. Hash new password
    const hashedPassword = await this.passwordService.hash(newPassword);

    // 5. Update user
    await this.userRepository.update(user.id, {
      password: hashedPassword,
    });
  }

  /**
   * Get user by ID
   */
  async getUserById(userId: string): Promise<PublicUser> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    const { password, ...publicUser } = user;
    return publicUser as PublicUser;
  }

  /**
   * Update user profile
   */
  async updateProfile(userId: string, updates: any): Promise<PublicUser> {
    // Remove sensitive fields
    const { password, role, ...safeUpdates } = updates;

    const user = await this.userRepository.update(userId, safeUpdates);
    const { password: _, ...publicUser } = user;
    return publicUser as PublicUser;
  }

  /**
   * Generate secure random token
   */
  private generateSecureToken(): string {
    return randomBytes(32).toString('hex');
  }
}
