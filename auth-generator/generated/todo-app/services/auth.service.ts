/**
 * Auth Service (Generated Template)
 * 
 * This is a template that shows the structure.
 * The actual implementation is in src/services/auth.service.ts
 * Generated by SmartSpec Auth Generator
 */

import { JWTService } from './jwt.service';
import { PasswordService } from './password.service';
import {
  User,
  PublicUser,
  RegisterInput,
  LoginInput,
  RegisterResult,
  LoginResult,
  TokenPair,
  AUTH_ERRORS,
} from '../types/auth.types';

export class AuthService {
  private jwtService: JWTService;
  private passwordService: PasswordService;

  constructor(jwtService: JWTService, passwordService: PasswordService) {
    this.jwtService = jwtService;
    this.passwordService = passwordService;
  }

  /**
   * Register new user
   */
  async register(input: RegisterInput): Promise<RegisterResult> {
    // 1. Validate password strength
    const passwordValidation = this.passwordService.validatePasswordStrength(input.password);
    if (!passwordValidation.isValid) {
      throw AUTH_ERRORS.WEAK_PASSWORD;
    }

    // 2. Check if user exists (database layer)
    // const existingUser = await userRepository.findByEmail(input.email);
    // if (existingUser) throw AUTH_ERRORS.USER_EXISTS;

    // 3. Hash password
    const hashedPassword = await this.passwordService.hashPassword(input.password);

    // 4. Create user (database layer)
    const user: User = {
      id: 'generated-id', // Would be generated by database
      email: input.email,
      password: hashedPassword,
      role: UserRole.USER,
      emailVerified: false,
      failedLoginAttempts: 0,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    // 5. Generate tokens
    const tokens = await this.jwtService.generateTokenPair({
      userId: user.id,
      email: user.email,
      role: user.role,
    });

    // 6. Remove password from response
    const { password, ...publicUser } = user;

    return {
      user: publicUser as PublicUser,
      tokens,
    };
  }

  /**
   * Login user
   */
  async login(input: LoginInput, user: User): Promise<LoginResult> {
    // Check if account is locked
    if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {
      throw AUTH_ERRORS.ACCOUNT_LOCKED;
    }

    // Verify password
    const isValid = await this.passwordService.verifyPassword(input.password, user.password);
    
    if (!isValid) {
      // Increment failed attempts
      user.failedLoginAttempts = (user.failedLoginAttempts || 0) + 1;
      
      // Lock account if max attempts reached
      if (user.failedLoginAttempts >= 5) {
        user.lockedUntil = new Date(Date.now() + 30 * 60 * 1000);
      }
      
      // Save user (database layer)
      // await userRepository.update(user);
      
      throw AUTH_ERRORS.INVALID_CREDENTIALS;
    }

    // Reset failed attempts on successful login
    if (user.failedLoginAttempts > 0) {
      user.failedLoginAttempts = 0;
      user.lockedUntil = undefined;
      // await userRepository.update(user);
    }

    // Generate tokens
    const tokens = await this.jwtService.generateTokenPair({
      userId: user.id,
      email: user.email,
      role: user.role,
    });

    const { password, ...publicUser } = user;

    return {
      user: publicUser as PublicUser,
      tokens,
    };
  }

  /**
   * Refresh tokens
   */
  async refreshTokens(refreshToken: string, user: User): Promise<TokenPair> {
    // Verify refresh token
    const payload = await this.jwtService.verifyRefreshToken(refreshToken);

    // Verify user matches token
    if (payload.userId !== user.id) {
      throw AUTH_ERRORS.INVALID_TOKEN;
    }

    // Generate new token pair
    return this.jwtService.generateTokenPair({
      userId: user.id,
      email: user.email,
      role: user.role,
    });
  }

  /**
   * Verify email
   */
  async verifyEmail(token: string, user: User): Promise<void> {
    if (user.emailVerificationToken !== token) {
      throw AUTH_ERRORS.INVALID_TOKEN;
    }

    if (user.emailVerificationExpires && new Date(user.emailVerificationExpires) < new Date()) {
      throw AUTH_ERRORS.INVALID_TOKEN;
    }

    user.emailVerified = true;
    user.emailVerificationToken = undefined;
    user.emailVerificationExpires = undefined;

    // Save user (database layer)
    // await userRepository.update(user);
  }

  /**
   * Request password reset
   */
  async requestPasswordReset(email: string): Promise<string> {
    // Find user (database layer)
    // const user = await userRepository.findByEmail(email);
    // if (!user) throw AUTH_ERRORS.USER_NOT_FOUND;

    // Generate reset token
    const resetToken = this.generateSecureToken();
    
    // Set token expiry (1 hour)
    const resetExpires = new Date(Date.now() + 60 * 60 * 1000);

    // Save token (database layer)
    // user.resetPasswordToken = resetToken;
    // user.resetPasswordExpires = resetExpires;
    // await userRepository.update(user);

    return resetToken;
  }

  /**
   * Reset password
   */
  async resetPassword(token: string, newPassword: string, user: User): Promise<void> {
    if (user.resetPasswordToken !== token) {
      throw AUTH_ERRORS.INVALID_TOKEN;
    }

    if (user.resetPasswordExpires && new Date(user.resetPasswordExpires) < new Date()) {
      throw AUTH_ERRORS.INVALID_TOKEN;
    }

    // Validate new password
    const validation = this.passwordService.validatePasswordStrength(newPassword);
    if (!validation.isValid) {
      throw AUTH_ERRORS.WEAK_PASSWORD;
    }

    // Hash new password
    const hashedPassword = await this.passwordService.hashPassword(newPassword);

    user.password = hashedPassword;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;

    // Save user (database layer)
    // await userRepository.update(user);
  }

  /**
   * Change password (authenticated user)
   */
  async changePassword(user: User, currentPassword: string, newPassword: string): Promise<void> {
    // Verify current password
    const isValid = await this.passwordService.verifyPassword(currentPassword, user.password);
    if (!isValid) {
      throw AUTH_ERRORS.INVALID_CREDENTIALS;
    }

    // Validate new password
    const validation = this.passwordService.validatePasswordStrength(newPassword);
    if (!validation.isValid) {
      throw AUTH_ERRORS.WEAK_PASSWORD;
    }

    // Hash new password
    const hashedPassword = await this.passwordService.hashPassword(newPassword);

    user.password = hashedPassword;

    // Save user (database layer)
    // await userRepository.update(user);
  }

  /**
   * Generate secure random token
   */
  private generateSecureToken(): string {
    return require('crypto').randomBytes(32).toString('hex');
  }
}
