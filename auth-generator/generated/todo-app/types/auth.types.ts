/**
 * Auth Types
 * 
 * Type definitions for authentication
 * Generated by SmartSpec Auth Generator
 */

/**
 * User roles
 */
export enum UserRole {
  USER = 'user',
  ADMIN = 'admin',
}

/**
 * Role hierarchy for permission checking
 */
export const ROLE_HIERARCHY: Record<UserRole, number> = {
  [UserRole.USER]: 0,
  [UserRole.ADMIN]: 1,
};

/**
 * Check if user has required role or higher
 */
export function hasRole(userRole: UserRole, requiredRole: UserRole): boolean {
  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];
}

/**
 * User entity
 */
export interface User {
  id: string;
  email: string;
  password: string;
  role: UserRole;
  emailVerified: boolean;
  emailVerificationToken?: string;
  emailVerificationExpires?: Date;
  failedLoginAttempts: number;
  lockedUntil?: Date;
  resetPasswordToken?: string;
  resetPasswordExpires?: Date;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * User without sensitive data
 */
export type PublicUser = Omit<User, 'password' | 'emailVerificationToken' | 'resetPasswordToken'>;

/**
 * JWT payload
 */
export interface JWTPayload {
  userId: string;
  email: string;
  role: UserRole;
  type: 'access' | 'refresh';
  iat?: number;
  exp?: number;
}

/**
 * Token pair
 */
export interface TokenPair {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

/**
 * Registration input
 */
export interface RegisterInput {
  email: string;
  password: string;
  name: string;
}

/**
 * Login input
 */
export interface LoginInput {
  email: string;
  password: string;
}

/**
 * Registration result
 */
export interface RegisterResult {
  user: PublicUser;
  tokens: TokenPair;
  verificationToken?: string;
}

/**
 * Login result
 */
export interface LoginResult {
  user: PublicUser;
  tokens: TokenPair;
}

/**
 * Password validation result
 */
export interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Auth configuration
 */
export interface AuthConfig {
  jwt: {
    algorithm: 'RS256' | 'HS256';
    accessTokenExpiry: string;
    refreshTokenExpiry: string;
    issuer: string;
    audience: string;
  };
  password: {
    minLength: number;
    requireUppercase: boolean;
    requireLowercase: boolean;
    requireNumbers: boolean;
    requireSpecialChars: boolean;
    saltRounds: number;
  };
  accountLockout: {
    maxAttempts: number;
    lockoutDuration: number; // in minutes
  };
  emailVerification: {
    tokenExpiry: number; // in hours
  };
  passwordReset: {
    tokenExpiry: number; // in hours
  };
}

/**
 * Default auth configuration
 */
export const DEFAULT_AUTH_CONFIG: AuthConfig = {
  jwt: {
    algorithm: 'RS256',
    accessTokenExpiry: '15m',
    refreshTokenExpiry: '7d',
    issuer: 'smartspec-app',
    audience: 'smartspec-users',
  },
  password: {
    minLength: 8,
    requireUppercase: false,
    requireLowercase: false,
    requireNumbers: false,
    requireSpecialChars: false,
    saltRounds: 10,
  },
  accountLockout: {
    maxAttempts: 5,
    lockoutDuration: 30,
  },
  emailVerification: {
    tokenExpiry: 24, // 24 hours
  },
  passwordReset: {
    tokenExpiry: 1, // 1 hour
  },
};

/**
 * Auth errors
 */
export class AuthError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message);
    this.name = 'AuthError';
  }
}

export const AUTH_ERRORS = {
  INVALID_CREDENTIALS: new AuthError('Invalid credentials', 'INVALID_CREDENTIALS', 401),
  USER_EXISTS: new AuthError('User already exists', 'USER_EXISTS', 409),
  USER_NOT_FOUND: new AuthError('User not found', 'USER_NOT_FOUND', 404),
  INVALID_TOKEN: new AuthError('Invalid or expired token', 'INVALID_TOKEN', 401),
  WEAK_PASSWORD: new AuthError('Password does not meet requirements', 'WEAK_PASSWORD', 400),
  ACCOUNT_LOCKED: new AuthError('Account is locked due to too many failed login attempts', 'ACCOUNT_LOCKED', 423),
  EMAIL_NOT_VERIFIED: new AuthError('Email not verified', 'EMAIL_NOT_VERIFIED', 403),
  UNAUTHORIZED: new AuthError('Unauthorized', 'UNAUTHORIZED', 401),
  FORBIDDEN: new AuthError('Insufficient permissions', 'FORBIDDEN', 403),
};
