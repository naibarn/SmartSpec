/**
 * Auth Middleware
 * 
 * JWT verification and authorization middleware
 * Generated by SmartSpec Auth Generator
 */

import { Request, Response, NextFunction } from 'express';
import { JWTService } from '../services/jwt.service';
import { User{{#if rbac.enabled}}, UserRole{{/if}} } from '../types/auth.types';

export interface AuthRequest extends Request {
  user?: User;
}

export class AuthMiddleware {
  private jwtService: JWTService;

  constructor(jwtService: JWTService) {
    this.jwtService = jwtService;
  }

  /**
   * Verify JWT token and attach user to request
   */
  authenticate = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      // Get token from header
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        res.status(401).json({
          success: false,
          error: 'No token provided',
        });
        return;
      }

      const token = authHeader.substring(7); // Remove 'Bearer ' prefix

      // Verify token
      const payload = await this.jwtService.verifyAccessToken(token);

      // Get user from database (this would be done by the database layer)
      // For now, we'll assume the user is retrieved and attached
      // In production, you would query the database here:
      // const user = await userRepository.findById(payload.userId);
      
      // Attach user to request
      req.user = {
        id: payload.userId,
        email: payload.email,
        {{#if rbac.enabled}}
        role: payload.role as UserRole,
        {{/if}}
        // Other user fields would be populated from database
      } as User;

      next();
    } catch (error) {
      res.status(401).json({
        success: false,
        error: 'Invalid or expired token',
      });
    }
  };

  {{#if rbac.enabled}}
  /**
   * Check if user has required role
   */
  requireRole = (allowedRoles: UserRole[]) => {
    return async (
      req: AuthRequest,
      res: Response,
      next: NextFunction
    ): Promise<void> => {
      try {
        const user = req.user;
        if (!user) {
          res.status(401).json({
            success: false,
            error: 'Unauthorized',
          });
          return;
        }

        if (!allowedRoles.includes(user.role)) {
          res.status(403).json({
            success: false,
            error: 'Insufficient permissions',
          });
          return;
        }

        next();
      } catch (error) {
        next(error);
      }
    };
  };

  {{#each rbac.roles}}
  /**
   * Require {{this.name}} role
   */
  require{{capitalize this.name}} = this.requireRole([UserRole.{{uppercase this.name}}]);

  {{/each}}
  {{/if}}

  /**
   * Optional authentication - attach user if token is valid, but don't fail if not
   */
  optionalAuth = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        next();
        return;
      }

      const token = authHeader.substring(7);
      const payload = await this.jwtService.verifyAccessToken(token);

      req.user = {
        id: payload.userId,
        email: payload.email,
        {{#if rbac.enabled}}
        role: payload.role as UserRole,
        {{/if}}
      } as User;

      next();
    } catch (error) {
      // Token invalid, but that's okay for optional auth
      next();
    }
  };

  {{#if features.accountLockout}}
  /**
   * Check if account is locked
   */
  checkAccountLockout = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const user = req.user;
      if (!user) {
        next();
        return;
      }

      // Check if account is locked
      if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {
        const remainingMinutes = Math.ceil(
          (new Date(user.lockedUntil).getTime() - Date.now()) / 60000
        );
        res.status(423).json({
          success: false,
          error: `Account is locked. Try again in ${remainingMinutes} minutes`,
        });
        return;
      }

      next();
    } catch (error) {
      next(error);
    }
  };
  {{/if}}

  {{#if features.emailVerification}}
  /**
   * Require email verification
   */
  requireEmailVerified = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const user = req.user;
      if (!user) {
        res.status(401).json({
          success: false,
          error: 'Unauthorized',
        });
        return;
      }

      if (!user.emailVerified) {
        res.status(403).json({
          success: false,
          error: 'Email not verified. Please verify your email first',
        });
        return;
      }

      next();
    } catch (error) {
      next(error);
    }
  };
  {{/if}}
}

/**
 * Helper to create middleware instance
 */
export function createAuthMiddleware(jwtService: JWTService): AuthMiddleware {
  return new AuthMiddleware(jwtService);
}
