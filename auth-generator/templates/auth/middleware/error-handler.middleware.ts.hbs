/**
 * Error Handler Middleware
 * 
 * Sanitizes errors before sending to client
 * Generated by SmartSpec Auth Generator
 */

import { Request, Response, NextFunction } from 'express';
import {
  AuthError,
  formatErrorResponse,
  isOperationalError,
} from '../errors/auth-errors';

/**
 * Error handler middleware
 * Sanitizes error messages to prevent information leakage
 */
export function errorHandler(
  err: Error,
  _req: Request,
  res: Response,
  _next: NextFunction
): void {
  // Log full error server-side for debugging
  if (process.env.NODE_ENV !== 'production') {
    console.error('Error:', err);
  } else {
    // In production, log only essential info
    console.error('Error:', {
      name: err.name,
      message: err.message,
      ...(err instanceof AuthError && { code: err.code }),
    });
  }

  // Check if it's an operational error
  if (!isOperationalError(err)) {
    // Programming error - log full details server-side
    console.error('Non-operational error:', err.stack);
  }

  // Sanitize error before sending
  const sanitized = sanitizeError(err);

  // Send sanitized response
  res.status(sanitized.statusCode).json({
    success: false,
    error: {
      message: sanitized.message,
      code: sanitized.code,
    },
  });
}

/**
 * Async error wrapper
 * Catches errors from async route handlers
 */
export function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<any>
) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

/**
 * 404 handler
 */
export function notFoundHandler(_req: Request, res: Response): void {
  res.status(404).json({
    success: false,
    error: {
      message: 'Resource not found',
      code: 'NOT_FOUND',
    },
  });
}

/**
 * Error sanitization map
 * Maps internal error messages to safe client messages
 */
const ERROR_MESSAGE_MAP: Record<string, string> = {
  // User enumeration prevention
  'User with this email already exists': 'Unable to complete registration',
  'User not found': 'Invalid credentials',
  'Email not found': 'Invalid credentials',
  
  // Token validation
  'Invalid verification token': 'Invalid or expired token',
  'Verification token has expired': 'Invalid or expired token',
  'Invalid reset token': 'Invalid or expired token',
  'Reset token has expired': 'Invalid or expired token',
  'Invalid refresh token': 'Invalid or expired token',
  'Refresh token has expired': 'Invalid or expired token',
  
  // Password validation
  'Password validation failed': 'Password does not meet security requirements',
  'Current password is incorrect': 'Invalid credentials',
  
  // Account status
  'Email is already verified': 'Email is already verified',
  'Account is locked': 'Account is temporarily locked',
};

/**
 * Sanitize error message
 * Replaces detailed error messages with generic ones
 */
export function sanitizeErrorMessage(message: string): string {
  // Check for exact match
  if (ERROR_MESSAGE_MAP[message]) {
    return ERROR_MESSAGE_MAP[message];
  }

  // Check for partial matches
  for (const [key, value] of Object.entries(ERROR_MESSAGE_MAP)) {
    if (message.includes(key)) {
      return value;
    }
  }

  // Default generic message
  return 'An error occurred';
}

/**
 * Enhanced error formatter with sanitization
 */
export function sanitizeError(err: Error): {
  message: string;
  code: string;
  statusCode: number;
} {
  // If it's already an AuthError, use it as-is (already sanitized)
  if (err instanceof AuthError) {
    return {
      message: err.message,
      code: err.code,
      statusCode: err.statusCode,
    };
  }

  // Otherwise, sanitize the message
  const sanitizedMessage = sanitizeErrorMessage(err.message);

  // Determine status code based on error type
  let statusCode = 500;
  let code = 'INTERNAL_ERROR';

  if (err.name === 'ValidationError') {
    statusCode = 400;
    code = 'VALIDATION_ERROR';
  } else if (err.name === 'UnauthorizedError') {
    statusCode = 401;
    code = 'UNAUTHORIZED';
  } else if (err.name === 'ForbiddenError') {
    statusCode = 403;
    code = 'FORBIDDEN';
  } else if (err.name === 'NotFoundError') {
    statusCode = 404;
    code = 'NOT_FOUND';
  }

  return {
    message: sanitizedMessage,
    code,
    statusCode,
  };
}
