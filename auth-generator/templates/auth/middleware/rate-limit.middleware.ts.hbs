/**
 * Rate Limiting Middleware
 * 
 * Prevents brute force attacks and abuse
 * Generated by SmartSpec Auth Generator
 */

import { Request, Response, NextFunction } from 'express';
import { RateLimitError } from '../errors/auth-errors';

/**
 * In-memory store for rate limiting
 * For production, use Redis or similar distributed cache
 */
class MemoryStore {
  private hits: Map<string, { count: number; resetTime: number }> = new Map();

  increment(key: string): { count: number; resetTime: number } {
    const now = Date.now();
    const record = this.hits.get(key);

    if (!record || now > record.resetTime) {
      // Create new record
      const resetTime = now + 60000; // 1 minute default
      this.hits.set(key, { count: 1, resetTime });
      return { count: 1, resetTime };
    }

    // Increment existing record
    record.count++;
    return record;
  }

  reset(key: string): void {
    this.hits.delete(key);
  }

  cleanup(): void {
    const now = Date.now();
    for (const [key, record] of this.hits.entries()) {
      if (now > record.resetTime) {
        this.hits.delete(key);
      }
    }
  }
}

// Global store instance
const store = new MemoryStore();

// Cleanup expired entries every minute
setInterval(() => store.cleanup(), 60000);

/**
 * Rate limit configuration
 */
export interface RateLimitConfig {
  windowMs: number;      // Time window in milliseconds
  maxRequests: number;   // Max requests per window
  message?: string;      // Custom error message
  skipSuccessfulRequests?: boolean;  // Don't count successful requests
  skipFailedRequests?: boolean;      // Don't count failed requests
  keyGenerator?: (req: Request) => string;  // Custom key generator
}

/**
 * Create rate limiter middleware
 */
export function createRateLimiter(config: RateLimitConfig) {
  const {
    windowMs,
    maxRequests,
    message,
    skipSuccessfulRequests = false,
    skipFailedRequests = false,
    keyGenerator = defaultKeyGenerator,
  } = config;

  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      // Generate unique key for this client
      const key = keyGenerator(req);

      // Get current count
      const { count, resetTime } = store.increment(key);

      // Set rate limit headers
      res.setHeader('X-RateLimit-Limit', maxRequests);
      res.setHeader('X-RateLimit-Remaining', Math.max(0, maxRequests - count));
      res.setHeader('X-RateLimit-Reset', new Date(resetTime).toISOString());

      // Check if limit exceeded
      if (count > maxRequests) {
        const retryAfter = Math.ceil((resetTime - Date.now()) / 1000);
        res.setHeader('Retry-After', retryAfter);
        throw new RateLimitError(retryAfter);
      }

      // Handle skip options
      if (skipSuccessfulRequests || skipFailedRequests) {
        const originalSend = res.send;
        res.send = function(data: any): Response {
          const statusCode = res.statusCode;
          
          if (
            (skipSuccessfulRequests && statusCode < 400) ||
            (skipFailedRequests && statusCode >= 400)
          ) {
            // Decrement count
            const record = store['hits'].get(key);
            if (record) {
              record.count = Math.max(0, record.count - 1);
            }
          }
          
          return originalSend.call(this, data);
        };
      }

      next();
    } catch (error) {
      next(error);
    }
  };
}

/**
 * Default key generator (IP-based)
 */
function defaultKeyGenerator(req: Request): string {
  // Try to get real IP from headers (for proxies)
  const forwarded = req.headers['x-forwarded-for'];
  const ip = forwarded
    ? (typeof forwarded === 'string' ? forwarded.split(',')[0] : forwarded[0])
    : req.ip || req.socket.remoteAddress || 'unknown';
  
  return `ratelimit:${ip}`;
}

/**
 * User-based key generator
 * Use this for authenticated endpoints
 */
export function userKeyGenerator(req: Request): string {
  const user = (req as any).user;
  if (user && user.userId) {
    return `ratelimit:user:${user.userId}`;
  }
  return defaultKeyGenerator(req);
}

/**
 * Email-based key generator
 * Use this for login/registration endpoints
 */
export function emailKeyGenerator(req: Request): string {
  const email = req.body?.email;
  if (email) {
    return `ratelimit:email:${email}`;
  }
  return defaultKeyGenerator(req);
}

// Pre-configured rate limiters based on spec
{{#if securitySettings.rateLimits}}
{{#each securitySettings.rateLimits}}
/**
 * Rate limiter for {{@key}} endpoints
 * {{this.maxRequests}} requests per {{this.windowMs}}ms
 */
export const {{camelCase @key}}RateLimiter = createRateLimiter({
  windowMs: {{this.windowMs}},
  maxRequests: {{this.maxRequests}},
  {{#if (eq @key "login")}}
  keyGenerator: emailKeyGenerator,
  skipSuccessfulRequests: false,
  {{/if}}
  {{#if (eq @key "registration")}}
  keyGenerator: emailKeyGenerator,
  {{/if}}
});

{{/each}}
{{else}}
/**
 * Default rate limiters
 */

// Login rate limiter: 5 attempts per 15 minutes
export const loginRateLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  maxRequests: 5,
  keyGenerator: emailKeyGenerator,
  skipSuccessfulRequests: false,
});

// Registration rate limiter: 3 registrations per hour
export const registrationRateLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000,  // 1 hour
  maxRequests: 3,
  keyGenerator: emailKeyGenerator,
});

// Password reset rate limiter: 3 requests per hour
export const passwordResetRateLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000,  // 1 hour
  maxRequests: 3,
  keyGenerator: emailKeyGenerator,
});

// Email verification rate limiter: 5 requests per hour
export const emailVerificationRateLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000,  // 1 hour
  maxRequests: 5,
  keyGenerator: emailKeyGenerator,
});

// General API rate limiter: 100 requests per 15 minutes
export const apiRateLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  maxRequests: 100,
});
{{/if}}

/**
 * Redis store for distributed rate limiting
 * Uncomment and configure for production use
 */
/*
import Redis from 'ioredis';

class RedisStore {
  private redis: Redis;

  constructor(redisUrl: string) {
    this.redis = new Redis(redisUrl);
  }

  async increment(key: string, windowMs: number): Promise<{ count: number; resetTime: number }> {
    const now = Date.now();
    const resetTime = now + windowMs;

    // Use Redis pipeline for atomic operations
    const pipeline = this.redis.pipeline();
    pipeline.incr(key);
    pipeline.pexpire(key, windowMs);
    
    const results = await pipeline.exec();
    const count = results?.[0]?.[1] as number || 1;

    return { count, resetTime };
  }

  async reset(key: string): Promise<void> {
    await this.redis.del(key);
  }
}

// To use Redis store:
// const redisStore = new RedisStore(process.env.REDIS_URL || 'redis://localhost:6379');
// Then modify createRateLimiter to use redisStore instead of memoryStore
*/
