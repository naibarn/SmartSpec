/**
 * JWT Service
 * 
 * Handles JWT token generation, verification, and decoding
 * Generated by SmartSpec Auth Generator
 */

import * as jwt from 'jsonwebtoken';
import { JWTPayload, TokenPair } from '../types/auth.types';

export class JWTService {
  private accessTokenSecret: string;
  private refreshTokenSecret: string;
  private accessTokenExpiry: string;
  private refreshTokenExpiry: string;
  private algorithm: jwt.Algorithm;
  private issuer?: string;
  private audience?: string;

  constructor() {
    this.accessTokenSecret = process.env.JWT_ACCESS_SECRET || process.env.JWT_SECRET || '';
    this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET || '';
    this.accessTokenExpiry = process.env.JWT_ACCESS_EXPIRY || '{{jwtSettings.accessTokenExpiry}}';
    this.refreshTokenExpiry = process.env.JWT_REFRESH_EXPIRY || '{{jwtSettings.refreshTokenExpiry}}';
    this.algorithm = (process.env.JWT_ALGORITHM || '{{jwtSettings.algorithm}}') as jwt.Algorithm;
    {{#if jwtSettings.issuer}}
    this.issuer = process.env.JWT_ISSUER || '{{jwtSettings.issuer}}';
    {{/if}}
    {{#if jwtSettings.audience}}
    this.audience = process.env.JWT_AUDIENCE || '{{jwtSettings.audience}}';
    {{/if}}

    if (!this.accessTokenSecret) {
      throw new Error('JWT_SECRET or JWT_ACCESS_SECRET environment variable is required');
    }
  }

  /**
   * Generate access token
   */
  generateAccessToken(payload: Omit<JWTPayload, 'type' | 'iat' | 'exp'>): string {
    const tokenPayload: Omit<JWTPayload, 'iat' | 'exp'> = {
      ...payload,
      type: 'access'
    };

    const options: jwt.SignOptions = {
      expiresIn: this.accessTokenExpiry,
      algorithm: this.algorithm
    };

    {{#if jwtSettings.issuer}}
    if (this.issuer) {
      options.issuer = this.issuer;
    }
    {{/if}}

    {{#if jwtSettings.audience}}
    if (this.audience) {
      options.audience = this.audience;
    }
    {{/if}}

    return jwt.sign(tokenPayload, this.accessTokenSecret, options);
  }

  /**
   * Generate refresh token
   */
  generateRefreshToken(payload: Omit<JWTPayload, 'type' | 'iat' | 'exp'>): string {
    const tokenPayload: Omit<JWTPayload, 'iat' | 'exp'> = {
      ...payload,
      type: 'refresh'
    };

    const options: jwt.SignOptions = {
      expiresIn: this.refreshTokenExpiry,
      algorithm: this.algorithm
    };

    {{#if jwtSettings.issuer}}
    if (this.issuer) {
      options.issuer = this.issuer;
    }
    {{/if}}

    {{#if jwtSettings.audience}}
    if (this.audience) {
      options.audience = this.audience;
    }
    {{/if}}

    return jwt.sign(tokenPayload, this.refreshTokenSecret, options);
  }

  /**
   * Generate token pair (access + refresh)
   */
  generateTokenPair(userId: string, email: string, role: string): TokenPair {
    const payload = { userId, email, role };
    
    const accessToken = this.generateAccessToken(payload);
    const refreshToken = this.generateRefreshToken(payload);
    
    // Calculate expiry in seconds
    const expiresIn = this.parseExpiry(this.accessTokenExpiry);

    return {
      accessToken,
      refreshToken,
      expiresIn
    };
  }

  /**
   * Verify access token
   */
  verifyAccessToken(token: string): JWTPayload {
    try {
      const options: jwt.VerifyOptions = {
        algorithms: [this.algorithm]
      };

      {{#if jwtSettings.issuer}}
      if (this.issuer) {
        options.issuer = this.issuer;
      }
      {{/if}}

      {{#if jwtSettings.audience}}
      if (this.audience) {
        options.audience = this.audience;
      }
      {{/if}}

      const payload = jwt.verify(token, this.accessTokenSecret, options) as JWTPayload;

      if (payload.type !== 'access') {
        throw new Error('Invalid token type');
      }

      return payload;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new Error('Token expired');
      } else if (error instanceof jwt.JsonWebTokenError) {
        throw new Error('Invalid token');
      }
      throw error;
    }
  }

  /**
   * Verify refresh token
   */
  verifyRefreshToken(token: string): JWTPayload {
    try {
      const options: jwt.VerifyOptions = {
        algorithms: [this.algorithm]
      };

      {{#if jwtSettings.issuer}}
      if (this.issuer) {
        options.issuer = this.issuer;
      }
      {{/if}}

      {{#if jwtSettings.audience}}
      if (this.audience) {
        options.audience = this.audience;
      }
      {{/if}}

      const payload = jwt.verify(token, this.refreshTokenSecret, options) as JWTPayload;

      if (payload.type !== 'refresh') {
        throw new Error('Invalid token type');
      }

      return payload;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new Error('Refresh token expired');
      } else if (error instanceof jwt.JsonWebTokenError) {
        throw new Error('Invalid refresh token');
      }
      throw error;
    }
  }

  /**
   * Decode token without verification (for debugging)
   */
  decodeToken(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload;
    } catch {
      return null;
    }
  }

  /**
   * Parse expiry string to seconds
   */
  private parseExpiry(expiry: string): number {
    const match = expiry.match(/^(\d+)([smhd])$/);
    if (!match) return 900; // Default 15 minutes

    const value = parseInt(match[1]);
    const unit = match[2];

    switch (unit) {
      case 's': return value;
      case 'm': return value * 60;
      case 'h': return value * 60 * 60;
      case 'd': return value * 24 * 60 * 60;
      default: return 900;
    }
  }
}
