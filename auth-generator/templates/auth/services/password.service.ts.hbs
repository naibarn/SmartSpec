/**
 * Password Service
 * 
 * Handles password hashing, comparison, and validation
 * Generated by SmartSpec Auth Generator
 */

import * as bcrypt from 'bcrypt';

export interface PasswordRequirements {
  minLength: number;
  requireUppercase: boolean;
  requireLowercase: boolean;
  requireNumbers: boolean;
  requireSpecialChars: boolean;
}

export interface PasswordValidationResult {
  valid: boolean;
  errors: string[];
}

export class PasswordService {
  private saltRounds: number;
  private requirements: PasswordRequirements;

  constructor() {
    this.saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS || '{{securitySettings.passwordRequirements.saltRounds}}');
    this.requirements = {
      minLength: parseInt(process.env.PASSWORD_MIN_LENGTH || '{{securitySettings.passwordRequirements.minLength}}'),
      requireUppercase: process.env.PASSWORD_REQUIRE_UPPERCASE === 'true' || {{securitySettings.passwordRequirements.requireUppercase}},
      requireLowercase: process.env.PASSWORD_REQUIRE_LOWERCASE === 'true' || {{securitySettings.passwordRequirements.requireLowercase}},
      requireNumbers: process.env.PASSWORD_REQUIRE_NUMBERS === 'true' || {{securitySettings.passwordRequirements.requireNumbers}},
      requireSpecialChars: process.env.PASSWORD_REQUIRE_SPECIAL === 'true' || {{securitySettings.passwordRequirements.requireSpecialChars}}
    };
  }

  /**
   * Hash password using bcrypt
   */
  async hash(password: string): Promise<string> {
    return bcrypt.hash(password, this.saltRounds);
  }

  /**
   * Compare password with hash
   */
  async compare(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  /**
   * Validate password against requirements
   */
  validate(password: string): PasswordValidationResult {
    const errors: string[] = [];

    // Check minimum length
    if (password.length < this.requirements.minLength) {
      errors.push(`Password must be at least ${this.requirements.minLength} characters long`);
    }

    // Check uppercase requirement
    if (this.requirements.requireUppercase && !/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter');
    }

    // Check lowercase requirement
    if (this.requirements.requireLowercase && !/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter');
    }

    // Check numbers requirement
    if (this.requirements.requireNumbers && !/[0-9]/.test(password)) {
      errors.push('Password must contain at least one number');
    }

    // Check special characters requirement
    if (this.requirements.requireSpecialChars && !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
      errors.push('Password must contain at least one special character');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Generate random password that meets requirements
   */
  generateSecurePassword(length: number = this.requirements.minLength): string {
    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const lowercase = 'abcdefghijklmnopqrstuvwxyz';
    const numbers = '0123456789';
    const special = '!@#$%^&*()_+-=[]{};\':"|,.<>/?';

    let chars = '';
    let password = '';

    // Ensure at least one of each required type
    if (this.requirements.requireUppercase) {
      chars += uppercase;
      password += uppercase[Math.floor(Math.random() * uppercase.length)];
    }

    if (this.requirements.requireLowercase) {
      chars += lowercase;
      password += lowercase[Math.floor(Math.random() * lowercase.length)];
    }

    if (this.requirements.requireNumbers) {
      chars += numbers;
      password += numbers[Math.floor(Math.random() * numbers.length)];
    }

    if (this.requirements.requireSpecialChars) {
      chars += special;
      password += special[Math.floor(Math.random() * special.length)];
    }

    // Fill remaining length
    for (let i = password.length; i < length; i++) {
      password += chars[Math.floor(Math.random() * chars.length)];
    }

    // Shuffle password
    return password.split('').sort(() => Math.random() - 0.5).join('');
  }

  /**
   * Calculate password strength (0-100)
   */
  calculateStrength(password: string): number {
    let strength = 0;

    // Length score (max 40 points)
    strength += Math.min(password.length * 2, 40);

    // Variety score (max 60 points)
    if (/[a-z]/.test(password)) strength += 10;
    if (/[A-Z]/.test(password)) strength += 15;
    if (/[0-9]/.test(password)) strength += 15;
    if (/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) strength += 20;

    return Math.min(strength, 100);
  }

  /**
   * Get password requirements for client-side validation
   */
  getRequirements(): PasswordRequirements {
    return { ...this.requirements };
  }
}
