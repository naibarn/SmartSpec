/**
 * Session Service
 * 
 * Manages user sessions and refresh token rotation
 * Generated by SmartSpec Auth Generator
 */

import { randomBytes } from 'crypto';

export interface Session {
  id: string;
  userId: string;
  refreshToken: string;
  deviceInfo?: string;
  ipAddress?: string;
  createdAt: Date;
  expiresAt: Date;
  lastUsedAt: Date;
}

export class SessionService {
  private sessions: Map<string, Session> = new Map();
  private userSessions: Map<string, Set<string>> = new Map();
  private maxSessionsPerUser: number = 5;

  /**
   * Create new session
   */
  createSession(
    userId: string,
    refreshToken: string,
    expiresIn: number,
    deviceInfo?: string,
    ipAddress?: string
  ): Session {
    const sessionId = this.generateSessionId();
    const now = new Date();

    const session: Session = {
      id: sessionId,
      userId,
      refreshToken,
      deviceInfo,
      ipAddress,
      createdAt: now,
      expiresAt: new Date(now.getTime() + expiresIn),
      lastUsedAt: now,
    };

    // Store session
    this.sessions.set(sessionId, session);

    // Track user sessions
    if (!this.userSessions.has(userId)) {
      this.userSessions.set(userId, new Set());
    }
    this.userSessions.get(userId)!.add(sessionId);

    // Enforce max sessions per user
    this.enforceMaxSessions(userId);

    return session;
  }

  /**
   * Get session by refresh token
   */
  getSessionByToken(refreshToken: string): Session | null {
    for (const session of this.sessions.values()) {
      if (session.refreshToken === refreshToken) {
        // Check if expired
        if (session.expiresAt < new Date()) {
          this.deleteSession(session.id);
          return null;
        }

        // Update last used
        session.lastUsedAt = new Date();
        return session;
      }
    }
    return null;
  }

  /**
   * Rotate refresh token (for security)
   */
  rotateRefreshToken(oldToken: string, newToken: string): boolean {
    const session = this.getSessionByToken(oldToken);
    if (!session) {
      return false;
    }

    // Update token
    session.refreshToken = newToken;
    session.lastUsedAt = new Date();

    return true;
  }

  /**
   * Delete session
   */
  deleteSession(sessionId: string): boolean {
    const session = this.sessions.get(sessionId);
    if (!session) {
      return false;
    }

    // Remove from user sessions
    const userSessionSet = this.userSessions.get(session.userId);
    if (userSessionSet) {
      userSessionSet.delete(sessionId);
      if (userSessionSet.size === 0) {
        this.userSessions.delete(session.userId);
      }
    }

    // Remove session
    this.sessions.delete(sessionId);

    return true;
  }

  /**
   * Delete session by refresh token
   */
  deleteSessionByToken(refreshToken: string): boolean {
    const session = this.getSessionByToken(refreshToken);
    if (!session) {
      return false;
    }

    return this.deleteSession(session.id);
  }

  /**
   * Delete all sessions for user
   */
  deleteUserSessions(userId: string): number {
    const sessionIds = this.userSessions.get(userId);
    if (!sessionIds) {
      return 0;
    }

    let count = 0;
    for (const sessionId of sessionIds) {
      this.sessions.delete(sessionId);
      count++;
    }

    this.userSessions.delete(userId);

    return count;
  }

  /**
   * Get user sessions
   */
  getUserSessions(userId: string): Session[] {
    const sessionIds = this.userSessions.get(userId);
    if (!sessionIds) {
      return [];
    }

    const sessions: Session[] = [];
    for (const sessionId of sessionIds) {
      const session = this.sessions.get(sessionId);
      if (session) {
        sessions.push(session);
      }
    }

    return sessions;
  }

  /**
   * Clean up expired sessions
   */
  cleanupExpiredSessions(): number {
    const now = new Date();
    let count = 0;

    for (const [sessionId, session] of this.sessions.entries()) {
      if (session.expiresAt < now) {
        this.deleteSession(sessionId);
        count++;
      }
    }

    return count;
  }

  /**
   * Enforce max sessions per user
   */
  private enforceMaxSessions(userId: string): void {
    const sessionIds = this.userSessions.get(userId);
    if (!sessionIds || sessionIds.size <= this.maxSessionsPerUser) {
      return;
    }

    // Get all sessions for user
    const sessions = Array.from(sessionIds)
      .map((id) => this.sessions.get(id))
      .filter((s): s is Session => s !== undefined)
      .sort((a, b) => a.lastUsedAt.getTime() - b.lastUsedAt.getTime());

    // Delete oldest sessions
    const toDelete = sessions.length - this.maxSessionsPerUser;
    for (let i = 0; i < toDelete; i++) {
      this.deleteSession(sessions[i].id);
    }
  }

  /**
   * Generate session ID
   */
  private generateSessionId(): string {
    return randomBytes(32).toString('hex');
  }

  /**
   * Start automatic cleanup (runs every hour)
   */
  startAutomaticCleanup(intervalMs: number = 60 * 60 * 1000): NodeJS.Timeout {
    return setInterval(() => {
      const count = this.cleanupExpiredSessions();
      if (count > 0) {
        console.log(`Cleaned up ${count} expired sessions`);
      }
    }, intervalMs);
  }
}
