/**
 * Auth Types
 * 
 * Type definitions for authentication
 * Generated by SmartSpec Auth Generator
 */

{{#if rbac.enabled}}
/**
 * User roles
 */
export enum UserRole {
  {{#each rbac.roles}}
  {{uppercase this.name}} = '{{this.name}}',
  {{/each}}
}

/**
 * Role hierarchy for permission checking
 */
export const ROLE_HIERARCHY: Record<UserRole, number> = {
  {{#each rbac.roles}}
  [UserRole.{{uppercase this.name}}]: {{@index}},
  {{/each}}
};

/**
 * Check if user has required role or higher
 */
export function hasRole(userRole: UserRole, requiredRole: UserRole): boolean {
  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];
}
{{/if}}

/**
 * User entity
 */
export interface User {
  id: string;
  email: string;
  password: string;
  {{#if rbac.enabled}}
  role: UserRole;
  {{/if}}
  {{#if features.emailVerification}}
  emailVerified: boolean;
  emailVerificationToken?: string;
  emailVerificationExpires?: Date;
  {{/if}}
  {{#if features.accountLockout}}
  failedLoginAttempts: number;
  lockedUntil?: Date;
  {{/if}}
  {{#if features.passwordReset}}
  resetPasswordToken?: string;
  resetPasswordExpires?: Date;
  {{/if}}
  {{#if userModel.fields}}
  {{#each userModel.fields}}
  {{#unless (includes ../excludedFields this.name)}}
  {{this.name}}{{#if this.optional}}?{{/if}}: {{this.type}};
  {{/unless}}
  {{/each}}
  {{/if}}
  createdAt: Date;
  updatedAt: Date;
}

/**
 * User without sensitive data
 */
export type PublicUser = Omit<User, 'password' | 'emailVerificationToken' | 'resetPasswordToken'>;

/**
 * JWT payload
 */
export interface JWTPayload {
  userId: string;
  email: string;
  {{#if rbac.enabled}}
  role: UserRole;
  {{/if}}
  type: 'access' | 'refresh';
  iat?: number;
  exp?: number;
}

/**
 * Token pair
 */
export interface TokenPair {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

/**
 * Registration input
 */
export interface RegisterInput {
  email: string;
  password: string;
  {{#if userModel.fields}}
  {{#each userModel.fields}}
  {{#unless (includes ../excludedFields this.name)}}
  {{this.name}}{{#if this.optional}}?{{/if}}: {{this.type}};
  {{/unless}}
  {{/each}}
  {{/if}}
}

/**
 * Login input
 */
export interface LoginInput {
  email: string;
  password: string;
}

/**
 * Registration result
 */
export interface RegisterResult {
  user: PublicUser;
  tokens: TokenPair;
  {{#if features.emailVerification}}
  verificationToken?: string;
  {{/if}}
}

/**
 * Login result
 */
export interface LoginResult {
  user: PublicUser;
  tokens: TokenPair;
}

/**
 * Password validation result
 */
export interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Auth configuration
 */
export interface AuthConfig {
  jwt: {
    algorithm: 'RS256' | 'HS256';
    accessTokenExpiry: string;
    refreshTokenExpiry: string;
    issuer: string;
    audience: string;
  };
  password: {
    minLength: number;
    requireUppercase: boolean;
    requireLowercase: boolean;
    requireNumbers: boolean;
    requireSpecialChars: boolean;
    saltRounds: number;
  };
  {{#if features.accountLockout}}
  accountLockout: {
    maxAttempts: number;
    lockoutDuration: number; // in minutes
  };
  {{/if}}
  {{#if features.emailVerification}}
  emailVerification: {
    tokenExpiry: number; // in hours
  };
  {{/if}}
  {{#if features.passwordReset}}
  passwordReset: {
    tokenExpiry: number; // in hours
  };
  {{/if}}
}

/**
 * Default auth configuration
 */
export const DEFAULT_AUTH_CONFIG: AuthConfig = {
  jwt: {
    algorithm: '{{jwtSettings.algorithm}}',
    accessTokenExpiry: '{{jwtSettings.accessTokenExpiry}}',
    refreshTokenExpiry: '{{jwtSettings.refreshTokenExpiry}}',
    issuer: '{{jwtSettings.issuer}}',
    audience: '{{jwtSettings.audience}}',
  },
  password: {
    minLength: {{securitySettings.passwordRequirements.minLength}},
    requireUppercase: {{securitySettings.passwordRequirements.requireUppercase}},
    requireLowercase: {{securitySettings.passwordRequirements.requireLowercase}},
    requireNumbers: {{securitySettings.passwordRequirements.requireNumbers}},
    requireSpecialChars: {{securitySettings.passwordRequirements.requireSpecialChars}},
    saltRounds: {{securitySettings.passwordRequirements.saltRounds}},
  },
  {{#if features.accountLockout}}
  accountLockout: {
    maxAttempts: {{securitySettings.accountLockout.maxAttempts}},
    lockoutDuration: {{securitySettings.accountLockout.lockoutDuration}},
  },
  {{/if}}
  {{#if features.emailVerification}}
  emailVerification: {
    tokenExpiry: 24, // 24 hours
  },
  {{/if}}
  {{#if features.passwordReset}}
  passwordReset: {
    tokenExpiry: 1, // 1 hour
  },
  {{/if}}
};

/**
 * Auth errors
 */
export class AuthError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message);
    this.name = 'AuthError';
  }
}

export const AUTH_ERRORS = {
  INVALID_CREDENTIALS: new AuthError('Invalid credentials', 'INVALID_CREDENTIALS', 401),
  USER_EXISTS: new AuthError('User already exists', 'USER_EXISTS', 409),
  USER_NOT_FOUND: new AuthError('User not found', 'USER_NOT_FOUND', 404),
  INVALID_TOKEN: new AuthError('Invalid or expired token', 'INVALID_TOKEN', 401),
  WEAK_PASSWORD: new AuthError('Password does not meet requirements', 'WEAK_PASSWORD', 400),
  {{#if features.accountLockout}}
  ACCOUNT_LOCKED: new AuthError('Account is locked due to too many failed login attempts', 'ACCOUNT_LOCKED', 423),
  {{/if}}
  {{#if features.emailVerification}}
  EMAIL_NOT_VERIFIED: new AuthError('Email not verified', 'EMAIL_NOT_VERIFIED', 403),
  {{/if}}
  UNAUTHORIZED: new AuthError('Unauthorized', 'UNAUTHORIZED', 401),
  FORBIDDEN: new AuthError('Insufficient permissions', 'FORBIDDEN', 403),
};
