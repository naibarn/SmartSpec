/**
 * Audit Logger
 * 
 * Logs security-relevant events for audit trail
 * Generated by SmartSpec Auth Generator
 */

export enum AuditEventType {
  // Authentication events
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILURE = 'LOGIN_FAILURE',
  LOGOUT = 'LOGOUT',
  REGISTER = 'REGISTER',
  
  // Password events
  PASSWORD_CHANGE = 'PASSWORD_CHANGE',
  PASSWORD_RESET_REQUEST = 'PASSWORD_RESET_REQUEST',
  PASSWORD_RESET_SUCCESS = 'PASSWORD_RESET_SUCCESS',
  
  // Email events
  EMAIL_VERIFICATION_SENT = 'EMAIL_VERIFICATION_SENT',
  EMAIL_VERIFIED = 'EMAIL_VERIFIED',
  
  // Account events
  ACCOUNT_LOCKED = 'ACCOUNT_LOCKED',
  ACCOUNT_UNLOCKED = 'ACCOUNT_UNLOCKED',
  
  // Token events
  TOKEN_REFRESH = 'TOKEN_REFRESH',
  TOKEN_REVOKED = 'TOKEN_REVOKED',
  
  // Access events
  ACCESS_DENIED = 'ACCESS_DENIED',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
}

export interface AuditLog {
  id?: string;
  timestamp: Date;
  eventType: AuditEventType;
  userId?: string;
  email?: string;
  ipAddress?: string;
  userAgent?: string;
  success: boolean;
  metadata?: Record<string, any>;
  errorMessage?: string;
}

export class AuditLogger {
  private logs: AuditLog[] = [];
  private maxLogs: number = 10000; // Keep last 10k logs in memory

  /**
   * Log an audit event
   */
  log(event: Omit<AuditLog, 'timestamp'>): void {
    const auditLog: AuditLog = {
      ...event,
      timestamp: new Date(),
    };

    // Add to in-memory logs
    this.logs.push(auditLog);

    // Trim if exceeds max
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }

    // Log to console (in production, send to external service)
    this.logToConsole(auditLog);

    // TODO: Send to external audit service (e.g., Elasticsearch, CloudWatch)
    // this.sendToExternalService(auditLog);
  }

  /**
   * Log authentication success
   */
  logLoginSuccess(userId: string, email: string, ipAddress?: string, userAgent?: string): void {
    this.log({
      eventType: AuditEventType.LOGIN_SUCCESS,
      userId,
      email,
      ipAddress,
      userAgent,
      success: true,
    });
  }

  /**
   * Log authentication failure
   */
  logLoginFailure(email: string, reason: string, ipAddress?: string, userAgent?: string): void {
    this.log({
      eventType: AuditEventType.LOGIN_FAILURE,
      email,
      ipAddress,
      userAgent,
      success: false,
      errorMessage: reason,
    });
  }

  /**
   * Log logout
   */
  logLogout(userId: string, email: string): void {
    this.log({
      eventType: AuditEventType.LOGOUT,
      userId,
      email,
      success: true,
    });
  }

  /**
   * Log registration
   */
  logRegister(userId: string, email: string, ipAddress?: string): void {
    this.log({
      eventType: AuditEventType.REGISTER,
      userId,
      email,
      ipAddress,
      success: true,
    });
  }

  /**
   * Log password change
   */
  logPasswordChange(userId: string, email: string): void {
    this.log({
      eventType: AuditEventType.PASSWORD_CHANGE,
      userId,
      email,
      success: true,
    });
  }

  /**
   * Log password reset request
   */
  logPasswordResetRequest(email: string, ipAddress?: string): void {
    this.log({
      eventType: AuditEventType.PASSWORD_RESET_REQUEST,
      email,
      ipAddress,
      success: true,
    });
  }

  /**
   * Log password reset success
   */
  logPasswordResetSuccess(userId: string, email: string): void {
    this.log({
      eventType: AuditEventType.PASSWORD_RESET_SUCCESS,
      userId,
      email,
      success: true,
    });
  }

  /**
   * Log email verification sent
   */
  logEmailVerificationSent(userId: string, email: string): void {
    this.log({
      eventType: AuditEventType.EMAIL_VERIFICATION_SENT,
      userId,
      email,
      success: true,
    });
  }

  /**
   * Log email verified
   */
  logEmailVerified(userId: string, email: string): void {
    this.log({
      eventType: AuditEventType.EMAIL_VERIFIED,
      userId,
      email,
      success: true,
    });
  }

  /**
   * Log account locked
   */
  logAccountLocked(userId: string, email: string, reason: string): void {
    this.log({
      eventType: AuditEventType.ACCOUNT_LOCKED,
      userId,
      email,
      success: true,
      metadata: { reason },
    });
  }

  /**
   * Log access denied
   */
  logAccessDenied(userId: string, email: string, resource: string, ipAddress?: string): void {
    this.log({
      eventType: AuditEventType.ACCESS_DENIED,
      userId,
      email,
      ipAddress,
      success: false,
      metadata: { resource },
    });
  }

  /**
   * Get recent logs
   */
  getRecentLogs(limit: number = 100): AuditLog[] {
    return this.logs.slice(-limit);
  }

  /**
   * Get logs by user
   */
  getLogsByUser(userId: string, limit: number = 100): AuditLog[] {
    return this.logs
      .filter((log) => log.userId === userId)
      .slice(-limit);
  }

  /**
   * Get logs by event type
   */
  getLogsByEventType(eventType: AuditEventType, limit: number = 100): AuditLog[] {
    return this.logs
      .filter((log) => log.eventType === eventType)
      .slice(-limit);
  }

  /**
   * Log to console (structured logging)
   */
  private logToConsole(log: AuditLog): void {
    const logData = {
      timestamp: log.timestamp.toISOString(),
      event: log.eventType,
      userId: log.userId,
      email: log.email,
      success: log.success,
      ip: log.ipAddress,
      ...(log.metadata && { metadata: log.metadata }),
      ...(log.errorMessage && { error: log.errorMessage }),
    };

    if (log.success) {
      console.log('[AUDIT]', JSON.stringify(logData));
    } else {
      console.warn('[AUDIT]', JSON.stringify(logData));
    }
  }
}

// Export singleton instance
export const auditLogger = new AuditLogger();
